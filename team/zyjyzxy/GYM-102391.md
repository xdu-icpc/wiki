---
title: GYM-102391  2019-2020 XX Open Cup, Grand Prix of Korea 训练记录
description: 训练记录
published: true
date: 2020-11-10T12:22:41.562Z
tags: 训练记录
editor: markdown
dateCreated: 2020-11-08T02:12:49.778Z
---

# 记录
赛时有效输出1h 剩余4h推箱子/想h 最后都没做出来 场上只过了AG

# 赛后补题
## H:[Maxmizer](https://codeforc.es/group/2l2uaz0vCx/contest/102391/problem/H)
给出两个排列A和B 每次操作可以交换A中相邻两个元素 求出使得a与b每个下标差的绝对值之和最大所需的最小交换次数

注意到大于n/2的元素对应的如果都是小于n/2的元素 则他们的差的绝对值之和是定值 且与最优答案相等(直接逆序)
因此可以考虑转换成01序列来做 让0对应1 1对应0 就能使得答案最大
那最优交换次数怎么求？
把A中的0和B中的1的下标按顺序存起来 计算对应下标的差的绝对值之和就行
为什么？
这样可以做到把0和对应的1连线 他们的连线没有交叉 从而把一个0交换到对应1的位置不会影响其他0的交换
```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 250007; 
#define ll long long
ll Abs(ll _a) { 
    return _a<0?-_a:_a;
}
ll a[maxn], b[maxn], c[125003], d[125003], e[125003];
int c1, n, c2, d1, d2; 
ll ans, ans2;
int main() {
    scanf("%d",&n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (a[i] <= n/ 2) c[++c1] = i;
        if (a[i] <= (n + 1) / 2) d[++d1] = i;
    }
    for (int i = 1; i <= n; i++) {
        scanf("%d", &b[i]);
        if (b[i] > n - n / 2) ans += Abs(i - c[++c2]); 
        if (b[i] > n - (n+1)/2) ans2 += Abs(i - d[++d2]);
    }
    cout << min(ans, ans2);
}
```


## F. [Hilbert's Hotel](https://codeforces.com/gym/102391/problem/F)

询问$2, 3$是独立的, 先看看$2$怎么做吧.

由于给定了组号, 并且各组之间也是独立的, 每组第$x$小的房间号是否可以用一个函数写出来呢? 答案显然是可以! 一开始第$0$组的函数为$g_0(x) = x$, 如果新来了$k_1$个旅客, 那么原来的函数都加上一个$k_1$, 比如$g_0(x)$变为$g_0(x) = x + k_1, (0 \le x)$, 新来的这一组函数为$g_1(x) = x, (0 \le x < k_1)$. 如果新来了无限个旅客, 那么原来的函数都乘以$2$, 比如$g_0(x) = 2x + 2k_1, (0 \le x)$, $g_1(x) = 2x, (0 \le x < k_1)$, 新来的这一组函数为$g_2(x) = 2x + 1, (0 \le x)$. 这样对于查询$2$, 就可以很方便地代值计算得到答案了.

结合题意和这些函数, 可以发现, 函数是一次函数. 又由于要对前缀进行区间修改, 可以考虑使用线段树, 那么找一个特定的组号就是单点查询. 进一步发现, 一次函数中, $x$的系数一定是$2$的次幂, 所以我们在保存节点信息时, 可以保存系数的指数, 以及截距. 答案需要取模, 所以截距可以取模保存. 因为是区间修改, 还需要打个lazy tag. 

对于询问$3$, 先来考虑暴力的做法. 直接存哪个房价住的是哪些人是不现实的, 但是我们可以"回溯". 即给出的$x$, 去考虑上一个操作$1$, 如果是入住$k$个人, 那么这个查询就相当于没有上一个操作$1$, 然后查询`3 (x-k)`. 当然如果$x-k$是负数, 那么显然这个$x$就是属于上一个操作$1$所修改的, 即答案为上一个操作$1$的组号. 入住无限个旅客也是同理, 让$x$除以$2$, 如果$x$是奇数, 那么就是属于上个操作$1$所修改的, 否则就可以看成在上一个操作$1$之前的查询`3 x/2`. 因为每个操作$1$, 对应每一组, 所以一直回溯, 便可找到相应的组了.

这样复杂度是$O(Q)$的, 加上查询就是$O(Q^2)$, 显然不行. 但是这个做法有优化的空间. 如果有一段连续的加$k$, 设他们的和为$sum$, 那么就可以直接$O(1)$判断答案是不是在这一段连续的加中. 即, 如果$x' = x - sum < 0$, 则在, 否则不在. 在的话可以二分, $O(logQ)$找到具体是哪一个点让他小于$0$. 不在的话, 说明需要再往前找. 连续一段加的前面一个是乘以$2$, 那么首先看$x'$的奇偶性, 像之前说的那样判断是找到了还是需要继续回溯.

记录乘以$2$出现的位置, 即可直接找到一段连续的加(见代码`p2[]`).

维护一段连续的加, 需要的是后缀和. 其实可以在操作的过程中$O(Q)$维护前缀和$pre[]$, 后缀和可以通过两个前缀和的差得到.

这样查询$3$的复杂度就只和乘以$2$的次数有关. 每次到乘以$2$的点都会让$x$减半, 那么查询$3$的复杂度就是$O(logx + logQ)$

需要特别注意的是$x = 0$(或者在回溯的过程中$x' = 0$)的情况. 如果此时前面都是乘以$2$的操作, 那么他会一直跑完这些操作, 这样复杂度会被卡成$O(Q^2)$, 所以我们需要特判$x = 0$(或$x' = 0$)的情况: 对于连续的乘以$2$, 直接跳到最前面第一个乘以$2$的操作即可. 可$O(Q)$在过程中预处理(见代码`last_2[], gid[]`).

总复杂度$O(Q(logQ + logx)) \approx O(QlogQ)$

### 代码

*(过程中需要用到`G-1`, 所以我的`G`从$1$开始; 第$x$小是直接代入, 所以$x-1$, 当然也可以初始化一次函数截距$b$为$10^9 + 6$, $x$直接代入)*

```cpp
const int maxn = 3e5+10;
const int P = 1e9+7;

int Plus(LL a, LL b) {
	return a + b >= P ? (a + b) % P : a + b;
}

int Mult(LL a, LL b) {
	return a * b >= P ? a * b % P : a * b;
}

struct SegmentTreeNode {
	int l, r, mid, pk, b;
} tree[maxn << 2];

int n, pw[maxn], G = 1, last_2[maxn], cnt = 0, gid[maxn];
LL pre[maxn];
vector<int> p2;

void Build(int v, int l, int r) {
	tree[v] = SegmentTreeNode{l, r, (l+r)>>1, 0, 0};
	if (l == r)
		return;
	else {
		Build(LCH(v), l, tree[v].mid);
		Build(RCH(v), tree[v].mid+1, tree[v].r);
	}
}

void Init() {
	pw[0] = 1;
	for (int i = 1; i <= n; i++)
		pw[i] = Mult(pw[i-1], 2);
	Build(1, 1, n);
}

void UpdateNode(int v, int pk, int b) {
	tree[v].b = Mult(pw[pk], tree[v].b);
	tree[v].b = Plus(tree[v].b, b);
	tree[v].pk += pk;
}

void Down(int v) {
	UpdateNode(LCH(v), tree[v].pk, tree[v].b);
	UpdateNode(RCH(v), tree[v].pk, tree[v].b);
	tree[v].pk = tree[v].b = 0;
}

void Update(int v, int l, int r, int pk, int b) {
	if (tree[v].l == l && tree[v].r == r)
		UpdateNode(v, pk, b);
	else {
		Down(v);
		if (l > tree[v].mid)
			Update(RCH(v), l, r, pk, b);
		else if (r <= tree[v].mid)
			Update(LCH(v), l, r, pk, b);
		else {
			Update(LCH(v), l, tree[v].mid, pk, b);
			Update(RCH(v), tree[v].mid+1, r, pk, b);
		}
	}
}

int Query(int v, int p, int x) {
	if (tree[v].l == tree[v].r)
		return Plus(Mult(pw[tree[v].pk], x), tree[v].b);
	Down(v);
	if (p > tree[v].mid)
		return Query(RCH(v), p, x);
	else 
		return Query(LCH(v), p, x);
}

int main() {
	scanf("%d", &n);
	Init();
	pre[1] = 0;
	last_2[1] = -1;
	for (int i = 1; i <= n; i++) {
		int op;
		scanf("%d", &op);
		if (op == 1){
			int k;
			scanf("%d", &k);
			if (k) {
				Update(1, 1, G++, 0, k);
				pre[G] = pre[G-1] + k;
				last_2[G] = 0;
			}
			else {
				Update(1, 1, G++, 1, 0);
				Update(1, G, G, 1, 1);
				pre[G] = 0;
				last_2[G] = last_2[G-1] ? last_2[G-1] : G;
				gid[G] = cnt++;
				p2.push_back(G);
			}
		}
		else if (op == 2){
			int g, x;
			scanf("%d%d", &g, &x);
			printf("%d\n", Query(1, g+1, x-1));
		}
		//下面写的和狗屎一样丑, 能力有限, 见谅
		else {
			int x;
			scanf("%d", &x);
			int cur = G, res = 1, L = 2, R = G, flag = 1;
			for (int i = p2.size() - 1; ~i; i--) {
				// 等于0也可回溯上一步
				if (x - pre[cur] >= 0) {
					x -= pre[cur];
					if (x & 1) {
						res = p2[i];
						flag = 0;
						break;
					}
					else {
						if (x == 0) {
							cur = last_2[p2[i]];
							i = gid[cur];
						}
						x >>= 1;
						cur = p2[i] - 1;
						R = cur;
					}
				}
				else {
					L = p2[i] + 1, R = cur;
					break;
				}
			}
			if (flag) {
				while (L <= R) {
					int mid = (L + R) >> 1;
					if (x - (pre[cur] - pre[mid-1]) < 0) {
						L = mid + 1;
						res = mid;
					}
					else
						R = mid - 1;
				}
			}
			printf("%d\n", res-1);
		}
	}
	return 0;
}
```

## J. [Parklife](https://codeforces.com/gym/102391/problem/J)

很自然地(zzs原话), 发现线段只有包含关系, 可以构成一棵树. 我们把最大的线段当成根, 权值为$0$即可. 由于需要对每个$k$都输出答案, 所以可以考虑dp.

先来看这样的一个状态: $dp(i, j)$表示对于子树$i$, 层次不超过$j$的最大值, 显然不能用这样的方程, 他的复杂度是$O(n^2)$. 不过我们可以从中考虑一些问题.

当$j=1$时, 我们把方程写过一下: $f(i)$表示子树$i$选一层的最大值, 转移方程为:

$$f(u) = max \\{ v(u), \sum_{v \in son_u} f(v) \\} $$

发现没有, 其实我们在算$k(j) = 1$的时候, 已经"算到了"$k = 2$的值(不管最大值是哪一个, 次大值加上$k=1$的值[就是这里做出来的最大值]就是$k=2$的值了), 只不过我们把他"放弃"了. 实际上我们可能还放弃了$k=3$甚至更多的值(这里也指"增量").

如果把这些值合理利用, 是不是就能够只跑一次了呢?

不妨这样想, 对每一个节点, 开一个大根堆, 维护的是$k$递增取值时的"增量", 即:

1. 堆中的第一个元素是取一层得到的值
2. 第二个元素是取两层在取一层上多加上的值
3. 以此类推

如何维护这样一个堆呢?

和$dp$一样, 把这个堆当成$dp$的值即可, 它也是从儿子转移过来的. 让儿子的堆的对应位置相加, 然后再把当前节点的$v$丢进去就行了. 

证明:

先证儿子对应位置相加的正确性: 由于各个儿子的选择是互相独立的, 而且儿子的堆中元素是排好了序的, 那么对应位置相加以后得到的新序列也是排好了序的, 所以对应位置直接相加即可.

再证丢进去一个$v$可行: 每做一个节点, 都新增一层, 所以把当前的$v$丢进堆里是必要的. 由于子树中, 各深度节点的选择是独立的, 所以根据贪心, 无论$v$在哪一个地方, 只要比子树的某些值更优, 即可选上$v$, $k$递增的时候再去选其他值($v$最小当然最后选$v$即可).

做完以后, 根的堆的前缀和就是答案了. 当然堆中元素很可能不满$n$个, 超过堆大小的$k$, 就已经可以全部选上了. 这些$k$的答案就是堆中所有元素的和(其实也就是所有节点的和).

合并堆的时候记得用启发式合并.

还有最后一个问题: 如何建树?

将线段按$l$从小到大, 长度从大到小(实际上可看成$r$, 因为$l$相等才比较$r$)排序, 可以发现, 这个顺序就是树的前序遍历. 开一个栈维护一条链: 如果栈顶线段不包含当前线段, 证明这两个线段不是父子关系, 那么栈顶出栈, 直到栈顶和当前线段是父子关系, 连边. 当前点入栈. 这样就可以$O(n)$建树了.

复杂度小于$O(nlog^2 n)$, 因为启发式合并的$O(logn)$跑不满. (官方题解证明了复杂度其实是$O(nlogn)$, 看不懂)

(官方题解太阴间, O(n^2)的dp一顿数学分析, 结果和我的做法一样...)

据说还有长链剖分的算法?? 有空学, 咕咕咕.

### 代码

```cpp
const int maxn = 2.5e5+10;

struct Segment {
	int l, r, w;
	bool operator < (const Segment &S) const {
		return l == S.l ? r > S.r : l < S.l;
	}
} segments[maxn];

int n;

vector<int> son[maxn];
vector<int> stk;

void Build() {
	stk.push_back(0);
	for (int i = 1; i <= n; i++) {
		Segment &s = segments[i];
		int fa = stk.back();
		while (!(segments[fa].l <= s.l && s.r <= segments[fa].r)) {
			stk.pop_back();
			fa = stk.back();
		}
		son[fa].push_back(i);
		stk.push_back(i);
	}
#ifdef D
	printf("Tree:\n");
	for (int i = 0; i <= n; i++) {
		printf("%d:\n", i);
		for (auto v : son[i])
			printf("%d ", v);
		puts("");
	}
#endif
}

MaxHeap heap[maxn];
int idx = 0;

// 启发式合并
int Merge(int x, int y) {
	vector<LL> pool;
	if (heap[x].size() > heap[y].size())
		swap(x, y);
	while (!heap[x].empty()) {
		pool.push_back(heap[x].top() + heap[y].top());
		heap[x].pop(), heap[y].pop();
	}
	for (auto t : pool)
		heap[y].push(t);
	return y;
}

// 返回的是当前点的堆(的下标)
int dfs(int u) {
	if (!son[u].size()) {
		heap[++idx].push(segments[u].w);
		return idx;
	}
	int cur = dfs(son[u][0]);
	for (int i = 1; i < son[u].size(); i++) {
		int p = dfs(son[u][i]);
		cur = Merge(cur, p);
	}
	heap[cur].push(segments[u].w);
	return cur;
}

int main() {
	scanf("%d", &n);
	segments[0] = Segment{1, 1000000, 0};
	for (int i = 1; i <= n; i++) {
		int l, r, w;
		scanf("%d%d%d", &l, &r, &w);
		segments[i] = Segment{l, r, w};
	}
	sort(segments, segments + n + 1);
	Build();
	int p = dfs(0);
	LL ans = 0;
	for (int i = 1; i <= n; i++) {
		if (!heap[p].empty()) {
			ans += heap[p].top();
			heap[p].pop();
		}
		printf("%lld ", ans);
	}
	return 0;
}
```