---
title: GYM-102391  2019-2020 XX Open Cup, Grand Prix of Korea 训练记录
description: 训练记录
published: true
date: 2020-11-08T02:12:55.410Z
tags: 
editor: undefined
dateCreated: 2020-11-08T02:12:49.778Z
---

## 记录
赛时有效输出1h 剩余4h推箱子/想h 最后都没做出来 场上只过了AG

## 赛后补题
H:[Maxmizer](https://codeforc.es/group/2l2uaz0vCx/contest/102391/problem/H)
给出两个排列A和B 每次操作可以交换A中相邻两个元素 求出使得a与b每个下标差的绝对值之和最大所需的最小交换次数

注意到大于n/2的元素对应的如果都是小于n/2的元素 则他们的差的绝对值之和是定值 且与最优答案相等(直接逆序)
因此可以考虑转换成01序列来做 让0对应1 1对应0 就能使得答案最大
那最优交换次数怎么求？
把A中的0和B中的1的下标按顺序存起来 计算对应下标的差的绝对值之和就行
为什么？
这样可以做到把0和对应的1连线 他们的连线没有交叉 从而把一个0交换到对应1的位置不会影响其他0的交换
```c++
#include<bits/stdc++.h>
using namespace std;
const int maxn = 250007; 
#define ll long long
ll Abs(ll _a) { 
    return _a<0?-_a:_a;
}
ll a[maxn], b[maxn], c[125003], d[125003], e[125003];
int c1, n, c2, d1, d2; 
ll ans, ans2;
int main() {
    scanf("%d",&n);
    for (int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        if (a[i] <= n/ 2) c[++c1] = i;
        if (a[i] <= (n + 1) / 2) d[++d1] = i;
    }
    for (int i = 1; i <= n; i++) {
        scanf("%d", &b[i]);
        if (b[i] > n - n / 2) ans += Abs(i - c[++c2]); 
        if (b[i] > n - (n+1)/2) ans2 += Abs(i - d[++d2]);
    }
    cout << min(ans, ans2);
}
```
