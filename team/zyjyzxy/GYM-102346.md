---
title: 2019-2020 ACM-ICPC Brazil Subregional Programming Contest
description: è®­ç»ƒè®°å½•
published: true
date: 2020-11-28T08:10:51.209Z
tags: è®­ç»ƒè®°å½•
editor: markdown
dateCreated: 2020-11-12T11:41:56.489Z
---

# è®°å½•

è’‹å¶æ¡¢, å¼ ç‚€æ°, æˆ‘åˆ†åˆ«å¼€é¢˜A, B, H, 12minæˆ‘è¿‡äº†H, 14minå¼ ç‚€æ°è¿‡äº†B, 35minè’‹å¶æ¡¢è¿‡äº†A.

æˆ‘, å¼ ç‚€æ°è¿‡å®Œäº†é¢˜ä»¥åç»§ç»­è¯»é¢˜, å¼ ç‚€æ°è¯»L, æˆ‘è¯»äº†M, ç¨å¾®æƒ³äº†æƒ³å‘ç°ä¸å¤ªä¼š, å’Œå¼ ç‚€æ°å•†é‡äº†ä¸€ä¸‹, å¼ ç‚€æ°è¯´åº”è¯¥å¯ä»¥äºŒåˆ†ç­”æ¡ˆ, äºæ˜¯åœ¨æƒ³M. æˆ‘åˆå»è¯»äº†G, å¥½åƒå’Œæ ‘å‰–æœ‰å…³? äºæ˜¯ä¸¢ç»™äº†å¼ ç‚€æ°. ç»§ç»­è¯»äº†L, æ˜¯ä¸€é“æ•°å­¦é¢˜, æ²¡å¤ªçœ‹æ‡‚, å’Œåˆšè¿‡å®ŒAçš„è’‹å¶æ¡¢è®¨è®º, è’‹å¶æ¡¢å»ºäº†ä¸ªæ•°å­¦æ¨¡å‹, å¹¶ä¸”å¼€å§‹æ‰“è¡¨. æˆ‘ç»§ç»­è¯»äº†K, æ•°æ•°é¢˜, ä¸¢ç»™è’‹å¶æ¡¢. ç„¶åå’Œè’‹å¶æ¡¢ä¸€èµ·æƒ³L, å¹¶å‘ç°äº†Lçš„åšæ³•, æˆ‘1h19minè¿‡äº†L. 

æ²¡å¸¦ç”µæº, ç”µè„‘æ²¡ç”µäº†, å›äº†ä¸€è¶Ÿå®¿èˆæ‹¿ç”µæº. æœŸé—´å¼ ç‚€æ°å’Œè’‹å¶æ¡¢åœ¨åšDå’ŒM, å¼ ç‚€æ°è¯´Dæ˜¯ä¸ªè£¸çš„é•¿é“¾å‰–åˆ†, æ‰“å®Œä»¥åWAç¬¬31ä¸ªç‚¹, ä¸çŸ¥é“ä¸ºä»€ä¹ˆ. ç„¶åå»æ‰“M, ç»†èŠ‚æ²¡æ‰“å‡ºæ¥, ç»™äº†è’‹å¶æ¡¢æ‰“. æˆ‘å›æ¥åç»§ç»­æ‘¸é±¼, å’Œå¼ ç‚€æ°æƒ³ä¸ºä»€ä¹ˆD WAäº†. è’‹å¶æ¡¢1h45minè¿‡äº†M, 

æˆ‘æå‡ºç‰¹åˆ¤ $k \ge \# leaf$ , æ”¹äº†ä»¥åäº¤ä¸€å‘è¿˜æ˜¯WA31. ä¸‰ä¸ªäººéƒ½å®åœ¨æƒ³ä¸å‡ºä¸ºä»€ä¹ˆDä¼šé”™äº†, äºæ˜¯æˆ‘é‡æ–°æ‰“äº†ä¸€é, 2h7minè¿‡äº†. å—¯?

è’‹å¶æ¡¢æ¨K, æˆ‘ç»§ç»­è¯»é¢˜, ç¿»è¯‘å®ŒG, å¼ ç‚€æ°å’Œè’‹å¶æ¡¢ä¸€çœ¼å°±çœ‹å‡ºæ˜¯ä¸ªè´¹ç”¨æµ, 2h53minè¿‡.

æœŸé—´å¼ ç‚€æ°åœ¨çœ‹J. æˆ‘æ‰“å®Œä»¥åè’‹å¶æ¡¢é©¬ä¸Šæ‰“K, æˆ‘å»çœ‹I. Iæ˜¯å›¾è®ºé¢˜, å’Œå¼ ç‚€æ°äº¤æµäº†ä¸€ä¸‹, æ²¡å¤ªæƒ³æ˜ç™½, å¼ ç‚€æ°ç»™æˆ‘è®²äº†J, æ‰“ç‰Œæ¨¡æ‹Ÿé¢˜. 

è¿™æ—¶è’‹å¶æ¡¢3h39minè¿‡äº†K, ç„¶åæ¥æƒ³I, äºæ˜¯å¼ ç‚€æ°å’Œæˆ‘å¼€å§‹æ‰“J. è’‹å¶æ¡¢æƒ³åˆ°äº†I, äºæ˜¯æˆ‘ä»¬åœæ­¢æ‰“J, è’‹å¶æ¡¢å¼€å§‹æ‰“I, æˆ‘åˆæ¨ç¿»äº†å¼ ç‚€æ°Jçš„æ‰“æ³•, å¼€å§‹æƒ³ç»†èŠ‚. è’‹å¶æ¡¢Iç»†èŠ‚æ²¡æƒ³æ¸…æ¥š, äºæ˜¯æˆ‘ä¸Šæœºæ‰“J, ä½†æ˜¯ç¬¬äºŒä¸ªæ ·ä¾‹æ­»å¾ªç¯äº†. å¾ˆè¿·.

æœ€åä¸€å°æ—¶å…¨å‘˜è´¡çŒ®ä¸º0, ç„¶åå°±ç»“æŸäº†.

# æ€»ç»“

1. è’‹å¶æ¡¢yyds!!!

2. åˆ†å·¥ä¸å½“, æˆ‘åº”è¯¥è¯»é¢˜, è€Œä¸æ˜¯æ•²é”®ç›˜. J å¼ ç‚€æ°æ²¡è¯»ä»”ç»†, æˆ‘STLä¸å¤ªä¼š, æµªè´¹äº†å¾ˆå¤šæ—¶é—´, å…¶å®Jæ˜¯ä¸ªå¾ˆç®€å•çš„æ¨¡æ‹Ÿ.

# è¡¥é¢˜

(ç›´æ¥copy[Wingsçš„åšå®¢](https://wingszeng.github.io/posts/acm/contest/vp-2019-2020-acm-icpc-brazil-subregional-programming-contest/))

_ç”±äºåšå®¢å’Œwikiæ¸²æŸ“mdçš„å¼•æ“ä¸ä¸€æ ·, wikiä¸Šå¯èƒ½æœ‰äº›æ’ç‰ˆå¾ˆé¬¼ç•œ. æ›´å¥½çš„é˜…è¯»ä½“éªŒè¯·è®¿é—®åšå®¢_

## A. Artwork

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/A)

$n \times m$å¤§å°çš„åœ°å›¾ä¸­æœ‰$k$ä¸ªæ‘„åƒå¤´, ç¬¬$i$ä¸ªçš„ä¾¦å¯ŸèŒƒå›´æ˜¯åŠå¾„ä¸º$s_i$çš„åœ†. ä»(0, 0)èµ°åˆ°(n, m), ä½†èƒ½è¢«æ‘„åƒå¤´å‘ç°. æ±‚æ˜¯å¦å¯è¡Œ.

$10 \le n, m \le 10^4$, $1 \le k \le 1000, 0 < s \le 10^4$

#### é¢˜è§£

æ‘„åƒå¤´çš„ç›‘æ§èŒƒå›´å¯çœ‹ä½œåœ†, ç›¸äº¤çš„åœ†åšå¹¶æŸ¥é›†, ç„¶åå†æ–°å¢ä¸¤ä¸ªç‚¹, ä¸€ä¸ªä¸ºåœ°å›¾çš„"å·¦ä¸‹è¾¹ç•Œä¹‹å¤–", å¦ä¸€ä¸ªä¸ºåœ°å›¾çš„"å³ä¸Šè¾¹ç•Œä¹‹å¤–". å¦‚æœæœ‰åœ†å’Œè¿™ä¸¤ä¸ªç‚¹ç›¸äº¤, é‚£ä¹ˆä¹ŸæŠŠä»–å¹¶è¿›å». æœ€ååˆ¤æ–­è¿™ä¸¤ä¸ªæ˜¯å¦åœ¨ä¸€ä¸ªå¹¶æŸ¥é›†ä¸­, æ˜¯åˆ™è¡¨é¢åœ°å›¾è¢«"åˆ†å‰²", ä¸èƒ½èµ°åˆ°; å¦åˆ™å¯ä»¥.

å¤æ‚åº¦$O(n\alpha(n))$

{{% code %}}

æ²¡å†™, ç›´æ¥copyè’‹å¶æ¡¢çš„. (è’‹å¶æ¡¢æ˜¯åˆ†äº†ä¸Šä¸‹å·¦å³å››ä¸ªè¾¹ç•Œå¤–çš„).

```cpp
#include<cstdio>
#include<algorithm>
#include<iostream>
#include<cstring>
#include<cmath>
#include<vector>
#include<queue>
#define LL long long
#define LD long double
const int MAXN=1015;
struct Sensor
{
	int x,y,s;
}S[MAXN];
int fa[MAXN];
int FindFa(int x)
{
	if(fa[x]==x)
		return x;
	return fa[x]=FindFa(fa[x]);
}
void Merge(int x,int y)
{
	int A=FindFa(x),B=FindFa(y);
	if(A!=B)
	{
		fa[A]=B;
	}
}
int jl(int x,int y,int X,int Y)
{
	return (x-X)*(x-X)+(y-Y)*(y-Y);
}
void Read(int &x)
{
	int f=1;x=0;char ch=getchar();
	while(ch<'0'||'9'<ch)
	{
		if(ch=='-')
			f=-1;
		ch=getchar();
	}
	while('0'<=ch&&ch<='9')
	{
		x=(x<<1)+(x<<3)+(ch^48);
		ch=getchar();
	}
	x=x*f;
}
int N,M,K;
void Init()
{
	for(int i=0;i<=K+5;i++)
		fa[i]=i;
}
int main()
{
	Read(M);
	Read(N);
	Read(K);
	Init();
	for(int i=1;i<=K;i++)
	{
		Read(S[i].x);
		Read(S[i].y);
		Read(S[i].s);
	}
	for(int i=1;i<=K;i++)
	{
		for(int j=1;j<K;j++)
		{
			if( jl(S[i].x,S[i].y,S[j].x,S[j].y) <= (S[i].s+S[j].s)*(S[i].s+S[j].s) )
			{
				Merge(i,j);
			}
		}
		if(S[i].x-S[i].s<=0)
		{
			Merge(i,K+4);
		}
		if(S[i].x+S[i].s>=M)
		{
			Merge(i,K+2);
		}
		if(S[i].y-S[i].s<=0)
		{
			Merge(i,K+1);
		}
		if(S[i].y+S[i].s>=N)
		{
			Merge(i,K+3);
		}
	}
	int key=0;
	if(FindFa(K+3)==FindFa(K+2)) key=1;
	if(FindFa(K+3)==FindFa(K+1)) key=1;
	if(FindFa(K+4)==FindFa(K+2)) key=1;
	if(FindFa(K+4)==FindFa(K+1)) key=1;
	if(key)
		printf("N\n");
	else
		printf("S\n");
}
```
{{% /code %}}

## B. Buffoon

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/B)

$n$ä¸ªæ•°$a_i$, æ±‚ç¬¬ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯æœ€å¤§.

$2 \le n \le 10^4, 1 \le a \le 10^5$

#### é¢˜è§£

ç­¾åˆ°, å¤æ‚åº¦$O(n)$

{{% code %}}

```cpp
int n, a[10007];
int main()
{
	Read(n);
	for (int i = 1; i <= n; i++) {
		Read(a[i]);
		if (a[i] > a[1]) {
			puts("N");
			return 0;
		}
	}
	puts("S");
	return 0;
}
```
{{% /code %}}

## D. Denouncing Mafia

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/D)

ç»™å‡ºä¸€æ£µå¤§å°ä¸º$n$çš„ä»¥$1$ä¸ºæ ¹çš„æ ‘, æœ€å¤šå¯ä»¥é€‰$k$ä¸ªç‚¹, é€‰äº†æŸä¸ªç‚¹å, æŠŠé€‰äº†çš„ç‚¹åˆ°æ ¹çš„è·¯å¾„ä¸Šçš„æ‰€æœ‰ç‚¹(åŒ…æ‹¬å½“å‰ç‚¹å’Œæ ¹)æ ‡è®°. æ±‚æœ€å°‘é€‰æ‹©å¤šå°‘ç‚¹, è®©æ‰€æœ‰ç‚¹è¢«æ ‡è®°.

$3 \le n \le 10^5, 1 \le k < n$

#### é¢˜è§£

é¦–å…ˆè‚¯å®šé€‰å¶å­æœ€ä¼˜, è¯æ˜å¾ˆç®€å•, ç•¥. ç„¶åæ˜¾ç„¶è´ªå¿ƒ, æ‰¾æœ€é•¿é“¾.

å¦‚ä½•æ‰¾æœ€é•¿é“¾? é•¿é“¾å‰–åˆ†.

å³æŠŠæ ‘é“¾å‰–åˆ†ä¸­, ä»¥å­æ ‘å¤§å°åˆ¤æ–­é‡å„¿å­æ”¹æˆä»¥å­æ ‘æ·±åº¦åˆ¤æ–­"æ·±å„¿å­".

åšå®Œä»¥åå°±å¾—åˆ°äº†æœ€é•¿é“¾çš„å‰–åˆ†. ç„¶åæ’åº, è´ªå¿ƒé€‰å°±å¯ä»¥äº†.

å¤æ‚åº¦$O(n)$

{{% code %}}

```cpp
const int maxn = 1e5+10;

int n, k, son[maxn], dep[maxn], maxdep[maxn], top[maxn];
vector<int> G[maxn], leaves;

void dfs1(int u, int d) {
	maxdep[u] = dep[u] = d;
	for (auto v : G[u]) {
		dfs1(v, d + 1);
		if (maxdep[v] > maxdep[u]) {
			maxdep[u] = maxdep[v];
			son[u] = v;
		}
	}
	if (!G[u].size())
		leaves.push_back(u);
}

void dfs2(int u, int t) {
	top[u] = t;
	if (!son[u])
		return;
	dfs2(son[u], t);
	for (auto v : G[u]) if (v != son[u])
		dfs2(v, v);
}

bool cmp(int u, int v) {
	return dep[u] - dep[top[u]] > dep[v] - dep[top[v]];
}

int main() {
	scanf("%d%d", &n, &k);
	for (int i = 2; i <= n; i++) {
		int f;
		scanf("%d", &f);
		G[f].push_back(i);
	}
	dfs1(1, 0);
	dfs2(1, 1);
	sort(leaves.begin(), leaves.end(), cmp);
	if (k >= leaves.size())
		printf("%d\n", n);
	else {
		int ans = 0;
		for (int i = 0; i < k; i++) {
			int u = leaves[i];
			ans += dep[u] - dep[top[u]] + 1;
		}
		printf("%d\n", ans);
	}
	return 0;
}
```
{{% /code %}}

## F. Forests in Danger

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/F)

æŸå›½å®¶çš„é¢†åœŸèŒƒå›´ä¸º$(X_1, Y_1)$åˆ°$(X_2, Y2)$çš„çŸ©å½¢. å…¶ä¸­æœ‰$n$æ¡å¹³è¡Œäºåæ ‡è½´çš„æ²³æµ$(x_{i1}, y_{i1}), (x_{i2}, y_{i2})$(å®Œå…¨åŒ…å«åœ¨é¢†åœŸå†…, ä¸”æ˜¯ä¸€æ¡ç›´çº¿).

ç°åœ¨è¯¥å›½è¦å¯¹æ²³æµå‘¨å›´è¿›è¡Œç»¿åŒ–, ç»¿åŒ–èŒƒå›´$r$è¡¨ç¤º: å¯¹äºæ²³æµä¸Šçš„æ¯ä¸€ä¸ªç‚¹å’Œè¢«ç»¿åŒ–çš„ç‚¹, è¿™ä¸¤ä¸ªç‚¹ä¹‹é—´çš„è·ç¦»æœ€å¤§ä¸º$r$. ä¸€æ¡æ²³æµå‘¨å›´è¢«ç»¿åŒ–çš„åœ°çœ‹ä¸Šå»æ˜¯ä¸€ä¸ªçŸ©å½¢. è¯¥å›½å¸Œæœ›æ‰€æœ‰çš„ç»¿åŒ–åœŸåœ°æ˜¯è¯¥å›½å›½åœŸé¢ç§¯çš„$P\\%$, æ±‚æ»¡è¶³è¯¥æ¡ä»¶çš„æœ€å°ç»¿åŒ–èŒƒå›´$r$.

#### é¢˜è§£

æ˜¾ç„¶äºŒåˆ†$r$.

å¯¹æ¯ä¸ªæ²³æµ, æˆ‘ä»¬å¯ä»¥ç®—å‡ºç»¿åŒ–çŸ©å½¢. å…ˆæŠŠè¿™äº›çŸ©å½¢å’Œå›½åœŸçŸ©å½¢æ±‚äº¤é›†, ç„¶åè¿™äº›çŸ©å½¢æ±‚å¹¶é›†å³å¯.

çŸ©å½¢é¢ç§¯å¹¶å¯ä»¥ç”¨æ‰«æçº¿ + çº¿æ®µæ ‘æ±‚.

éœ€è¦æ³¨æ„ä»¥ä¸‹ä¸¤ç‚¹:

1. ä¸èƒ½ç›´æ¥æ”¾åˆ°å¶å­ä¿®æ”¹(å¦‚æœè¿™æ ·çš„è¯åŒºé—´æ“ä½œæœ‰ä»€ä¹ˆæ„ä¹‰å‘¢?)

æ­£ç¡®çš„åšæ³•æ˜¯è®¾ä¸€ä¸ªå˜é‡ `cover`, è¡¨ç¤ºå®Œå…¨è¦†ç›–è¿™ä¸€ä¸ªåŒºé—´çš„æ¬¡æ•°.

åœ¨push upçš„æ—¶å€™, ä¸å¯¹ `cover` è¿›è¡Œä»»ä½•ä¿®æ”¹, è¿™æ ·æ¯æ¬¡è®¿é—®åˆ° `cover` ä¸ä¸º0çš„åŒºé—´, æˆ‘ä»¬å°±çŸ¥é“ä»–ä¸€å®šæ˜¯è¢«è¦†ç›–äº†çš„; å¦åˆ™å‘ä¸‹æ‰¾.

å¦‚æœ `cover` ä¸ä¸º0, é‚£ä¹ˆéœ€è¦æ›´æ–° `val` ä¸ºè¯¥åŒºé—´çš„é•¿åº¦; å¦åˆ™éœ€è¦ä»ä¸‹ç½‘ä¸Šæ›´æ–°.

2. æŸ¥è¯¢æ°¸è¿œæ˜¯æ ¹, æ‰€ä»¥ä¸éœ€è¦æ‰“lazy tag.

3. æœ¬é¢˜ç»†èŠ‚: ç”±äºæˆ‘ç”¨çº¿æ®µæ ‘ç»´æŠ¤äº†ä¸¤ä¸ªè¾¹ç•Œçš„é—­åŒºé—´(å®½åº¦ä¸º$r-l+1$), è€Œè¿™é¢˜æ˜¯è¿ç»­çš„, å®é™…ä¸Šå®½åº¦åº”è¯¥ä¸º$r-l$, æ‰€ä»¥åœ¨å¤„ç†çº¿æ®µæ ‘çš„æ—¶å€™æˆ‘ä¸¢è¿›å»çš„æ˜¯`update(l, r-1)`

4. å¦‚æœæ˜¯ç¦»æ•£çš„ç‚¹çš„é¢ç§¯, åˆ™ä¸éœ€è¦è¿›è¡Œä¸Šè¿°-1å¤„ç†, ä½†åŒæ—¶éœ€è¦å¯¹"-1çš„çº¿æ®µ"( `update(l, r, -1)`çš„åŒºé—´ )è¿›è¡Œy+1å¤„ç†. åŸå› å¦‚ä¸‹å›¾æ‰€ç¤º:

![ç¦»æ•£ç‚¹çŸ©å½¢é¢ç§¯](https://wingszeng.github.io/img/vp-2019-2020-acm-icpc-brazil-subregional-programming-contest/plus.jpg)

å¤æ‚åº¦$O(nlog^2 n)$

{{% code %}}

```cpp
const int maxn = 1e4+10;
const int maxx = 1e5+10;

struct Node {
	int l, r, mid, is_cover, val;
}tree[maxx<<2];

struct Seg {
	int x1, y1, x2, y2, d;
	Seg() {}
	Seg(int x1_, int y1_, int x2_, int y2_, int d_ = 0) {
		x1 = x1_, y1 = y1_, x2 = x2_, y2 = y2_;
		if (x1 > x2)
			swap(x1, x2);
		if (y1 > y2)
			swap(y1, y2);
		d = d_;
	}
	bool operator < (const Seg &S) const {
		return y1 == S.y1 ? x1 < S.x1 : y1 < S.y1;
	}
} segments[maxn], horizontal[maxn<<1];

int xx1, yy1, xx2, yy2;
int n, p;
LL area;

void Build(int u, int l, int r) {
	tree[u] = Node{l, r, (l+r)>>1, 0, 0};
	if (l < r) {
		Build(LCH(u), l, tree[u].mid);
		Build(RCH(u), tree[u].mid + 1, r);
	}
}

void Update(int u, int l, int r, int d) {
	if (tree[u].l == l && tree[u].r == r) {
		if (l == r) {
			tree[u].is_cover += d;
			tree[u].val = tree[u].is_cover > 0;
		}
		else {
			tree[u].is_cover += d;
			tree[u].val = tree[u].is_cover ? tree[u].r - tree[u].l + 1 : tree[LCH(u)].val + tree[RCH(u)].val;
		}
	}
	else {
		if (r <= tree[u].mid)
			Update(LCH(u), l, r, d);
		else if (l > tree[u].mid)
			Update(RCH(u), l, r, d);
		else {
			Update(LCH(u), l, tree[u].mid, d);
			Update(RCH(u), tree[u].mid + 1, r, d);
		}
		tree[u].val = tree[u].is_cover ? tree[u].r - tree[u].l + 1 : tree[LCH(u)].val + tree[RCH(u)].val;
	}
}

void Push(int cur, int r) {
	Seg &s = segments[cur];
	int sx1 = max(xx1, s.x1 - r), sx2 = min(xx2, s.x2 + r) - 1;
	int sy1 = max(yy1, s.y1 - r), sy2 = min(yy2, s.y2 + r);
	horizontal[cur] = Seg(sx1, sy1, sx2, sy1, 1);
	horizontal[cur + n] = Seg(sx1, sy2, sx2, sy2, -1);
}

bool Check(int r) {
	for (int i = 1; i <= n; i++)
		Push(i, r);
	sort(horizontal + 1, horizontal + 1 + n + n);
	Build(1, xx1, xx2);
	LL cur = 0;
	int pre_y = horizontal[1].y1;
	for (int i = 1; i <= n<<1; i++) {
		int x1 = horizontal[i].x1, x2 = horizontal[i].x2, y = horizontal[i].y1, d = horizontal[i].d;
		int h = y - pre_y, w = tree[1].val;
		cur += 1ll * h * w;
		Update(1, x1, x2, d);
		pre_y = y;
	}
	return ((cur * 100) >= (area * p));
}

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		int x1, y1, x2, y2;
		scanf("%d%d%d%d", &x1, &y1, &x2, &y2);
		segments[i] = Seg(x1, y1, x2, y2);
	}
	scanf("%d%d%d%d%d", &p, &xx1, &yy1, &xx2, &yy2);
	area = 1ll * (xx2 - xx1) * (yy2 - yy1);
	int l = 1, r = max(xx2, yy2), ans = -1;
	while (l <= r) {
		int mid = (l+r)>>1;
		if (Check(mid)) {
			r = mid - 1;
			ans = mid;
		}
		else
			l = mid + 1;
	}
	printf("%d\n", ans);
	return 0;
}
```
{{% /code %}}

## E. Exhibition of Clownfish

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/E)

æŸæ°´æ—é¦†æœ‰ä¸€ç§ç¥å¥‡çš„ğŸŸ, å½“æŸä¸€ä¸ªé±¼ç¼¸é‡Œæ²¡æœ‰é›Œé±¼æ—¶, æŸä¸€æ¡é›„é±¼ä¼šå˜æˆé›Œé±¼. æ°´æ—é¦†é‡Œæœ‰$n$ä¸ªé±¼ç¼¸, å…¶ä¸­ç¬¬$i$ä¸ªé±¼ç¼¸ä¸­æœ‰$a_i$æ¡é›„é±¼å’Œ$b_i$æ¡é›Œé±¼(ä¿è¯åˆå§‹çŠ¶æ€åˆæ³•). æŠŠæŸä¸€ä¸ªé±¼ç¼¸ä¸­çš„ä¸€æ¡é±¼ç§»åŠ¨åˆ°å¦ä¸€ä¸ªé±¼ç¼¸éœ€è¦$1$ç‚¹èŠ±è´¹. æ±‚æŠŠæ‰€æœ‰é›„é±¼å˜æˆé›Œé±¼çš„æœ€å°èŠ±è´¹.

$2 \le n \le 3000, 0 \le a, b \le 10^5, a = 0 \ or\ b > 0$

#### é¢˜è§£

_å…³é”®ç‚¹éƒ½æƒ³å‡ºæ¥äº†, ä½†æ˜¯ä¸å¤ªä¼šå®ç°, æäº†å¥½ä¹…å¥½ä¹…å¥½ä¹…ğŸ˜­_

å…ˆè¿›è¡Œä¸€ä¸‹ç‰¹åˆ¤, å¦‚æœæ²¡æœ‰é›„é±¼, ç›´æ¥è¾“å‡º$0$å³å¯.

å…ˆè€ƒè™‘æ²¡æœ‰ç©ºç¼¸çš„æƒ…å†µ.

å¯¹ä¸€ä¸ªéç©ºé±¼ç¼¸, æˆ‘ä»¬åªä¼šè¿›è¡Œä»¥ä¸‹æ“ä½œä¹‹ä¸€:

1. æŠŠæ‰€æœ‰é›„é±¼æ‹¿å‡ºæ¥, ç§»åŠ¨åˆ°å…¶ä»–ç¼¸é‡Œ(å¯èƒ½æ˜¯å¤šä¸ªé±¼ç¼¸);
2. æŠŠæ‰€æœ‰é›Œé±¼æ‹¿å‡ºæ¥, è®©é›„é±¼ä¾æ¬¡å˜æˆé›Œé±¼, å†ä¸€ä¸ªä¸€ä¸ªæ‹¿é›Œé±¼, æœ€åç•™ä¸€åªé›Œé±¼. æ‹¿å‡ºæ¥çš„é±¼ç§»åŠ¨åˆ°å…¶ä»–ç¼¸é‡Œ(å¯èƒ½æ˜¯å¤šä¸ªé±¼ç¼¸).

è¯æ˜ç®€å•, ç•¥.

æˆ‘ä»¬æŠŠè¿›è¡Œç¬¬ä¸€ç§æ“ä½œçš„é±¼ç¼¸ç§°ä¸º$M$, è¿›è¡Œç¬¬äºŒç§æ“ä½œçš„é±¼ç¼¸ç§°ä¸º$F$.

æ‰‹ç©å¯ä»¥å‘ç°æœ‰ä»¥ä¸‹æ€§è´¨:

1. $M$æ‹¿å‡ºæ¥çš„é±¼ä¸€å®šä¼šç§»åŠ¨åˆ°æŸäº›$F$ä¸­

è¯æ˜:

$M$($a_i, b_i$)æ‹¿å‡ºæ¥çš„é›„é±¼$a_i$ä¼šæ”¾åˆ°$F$çš„é›„é±¼é‡Œ, è®©æ‹¿è¿‡æ¥çš„é›„é±¼$a_i$å˜æˆé›Œé±¼çš„æœ€ä¼˜æ–¹å¼å°±æ˜¯è¿™ä¸ª$F$è¿›è¡Œä»–çš„æ“ä½œ, è¿™æ ·è¿™$a_i$æ¡é›„é±¼ä¼šè¢«ç§»åŠ¨ä¸¤æ¬¡, è´¡çŒ®ä¸º$2a_i$. å¦‚æœä¸æ˜¯è¿™æ ·çš„æ“ä½œ, é‚£ä¹ˆåªå¯èƒ½æ˜¯æŠŠè¿™äº›é±¼å†æ”¾åˆ°å…¶ä»–ç¼¸å†…, è¿™æ ·è´¡çŒ®ä¸€å®šä¼šå¤§äº$2a_i$, ä¸ä¼˜. å¦‚æœæ˜¯æŠŠ$M$æ”¾åˆ°å…¶ä»–$M$é‡Œ, ä¹Ÿä¼šé€ æˆè´¡çŒ®å¤§äº$2a_i$, ä¸ä¼˜.

æ‰€ä»¥, $M$çš„è´¡çŒ®æ˜¯$2a_i$.

2. $F$æ‹¿å‡ºæ¥çš„é±¼ä¸€å®šä¼šç§»åŠ¨åˆ°æŸäº›$M$ä¸­

è¯æ˜:

æ”¾åˆ°$M$ä¸­, ç”±äº$M$ä¸­çš„é›„é±¼ä¸éœ€è¦é€šè¿‡ç§»åŠ¨é›Œé±¼è®©é›„é±¼å˜æ€§, æ‰€ä»¥æ”¾å¥½ä»¥åå°±ä¸ç”¨åŠ¨äº†. å‡å¦‚$F$($a_j, b_j$)æ‹¿å‡ºæ¥çš„é±¼$(a_i + b_j - 1)$æ”¾åœ¨æŸäº›å…¶ä»–$F$ä¸­, åˆ™è¿™äº›é±¼è¿˜å¯èƒ½éœ€è¦å†æ‹¿å‡ºæ¥(ç›®æ ‡$F$æœ‰é›„é±¼çš„è¯), è´¡çŒ®ä¼šå¢åŠ , ä¸ä¼˜.

æ‰€ä»¥, $F$çš„æ€»è´¡çŒ®æ˜¯$a_j + b_j - 1$.

ç”±ä¸Šè¿°æ€§è´¨, å¯ä»¥æ¨çŸ¥:

3. è‡³å°‘å­˜åœ¨ä¸€ä¸ª$M$å’Œä¸€ä¸ª$F$æ‰æ˜¯å¯è¡Œçš„.

é‚£ä¹ˆ, æˆ‘ä»¬çš„ä»»åŠ¡å°±æ˜¯ç»™$n$ä¸ªéç©ºçš„é±¼ç¼¸æ ‡å·.

äº‹å®ä¸Šå¦‚æœé¢˜ç›®åˆ°è¿™é‡Œå°±ç»“æŸäº†, æˆ‘ä»¬å¯ä»¥ç›´æ¥è´ªå¿ƒè§£å†³.

ä½†æ˜¯! è¿™é“é¢˜æœ‰ç©ºé±¼ç¼¸! åŠ å…¥ç©ºé±¼ç¼¸ä¹‹åå°±å˜å¾—å¤æ‚å¤šäº†.

ç©ºé±¼ç¼¸æœ‰è¿™äº›ä½œç”¨:

1. ä½œä¸ºä¸€ä¸ª _é›„é±¼æ¶ˆé™¤å™¨_

ç”±å‰ä¸¤æ¡æ€§è´¨æˆ‘ä»¬å¯ä»¥å¾—åˆ°, åœ¨æ²¡æœ‰ç©ºé±¼ç¼¸çš„æƒ…å†µä¸‹, $M$ä¸­çš„ä¸€åªé›„é±¼çš„è´¡çŒ®ä¸º$2$. å¦‚æœæˆ‘ä»¬æŠŠè¿™ä¸€æ¡é±¼ç§»åŠ¨åˆ°ç©ºé±¼ç¼¸é‡Œ, è´¡çŒ®å°±æ˜¯$1$äº†, æ›´ä¼˜.

2. ä½œä¸ºä¸€ä¸ª$M$

å¦‚æœæ‰€æœ‰çš„éç©ºé±¼ç¼¸éƒ½æ˜¯$F$çš„è¯, å¯ä»¥æŠŠä»–ä»¬ç§»åŠ¨åˆ°ç©ºé±¼ç¼¸å†….

3. ä½œä¸ºä¸€ä¸ª$F$

å¦‚æœæ‰€æœ‰éç©ºé±¼ç¼¸éƒ½æ˜¯$M$çš„è¯, å¯ä»¥æŠŠä»–ä»¬éƒ½ç§»åŠ¨åˆ°ç©ºé±¼ç¼¸å†…, ç„¶åå†å¯¹æ”¶é›†äº†é›„é±¼çš„ç©ºé±¼ç¼¸è¿›è¡Œ$F$çš„æ“ä½œ(å¦‚æœæœ‰å¿…è¦).

ä½œç”¨$2,3$å‰Šå¼±äº†å¯¹éç©ºé±¼ç¼¸çš„"è‡³å°‘ä¸€ä¸ªä¸º$M$, ä¸€ä¸ªä¸º$F$"çš„é™åˆ¶æ¡ä»¶, å³å¯ä»¥å…¨æ˜¯$M$æˆ–è€…$F$.

åŒæ—¶, è¿˜æœ‰è¿™æ ·çš„æ€§è´¨:

ç§»åŠ¨åˆ°ç©ºé±¼ç¼¸é‡Œçš„é±¼ä¸€å®šæ˜¯æŸä¸ª$M$å†…çš„é›„é±¼

è¯æ˜:

ç”±ä½œç”¨1å¯å¾—, è¿™æ ·åšå¯ä»¥ä½¿ç­”æ¡ˆæ›´ä¼˜. $M$çš„é›Œé±¼ä¸éœ€è¦ç§»åŠ¨. $F$çš„é›„é±¼æˆ–è€…é›Œé±¼ç§»åŠ¨åˆ°è¿™é‡Œ, è´¡çŒ®æ˜¯$1$; è€ŒåŸæ¥çš„è´¡çŒ®ä¹Ÿæ˜¯$1$, ç§»åŠ¨çš„è¯ä¸ä»…ä¸ä¼šä½¿ç­”æ¡ˆæ›´ä¼˜, è¿˜ä¼šæµªè´¹ä¸€ä¸ªå¯èƒ½å¯ä»¥å‡å°ç­”æ¡ˆçš„ç©ºé±¼ç¼¸, ä¸ä¼˜.

è´ªå¿ƒä¸€ä¸‹, å½“ç„¶æ˜¯æŠŠå°½é‡å¤šçš„$M$ä¸­çš„é›„é±¼ç§»åŠ¨åˆ°ç©ºé±¼ç¼¸ä¸­.

é‚£ä¹ˆ, å“ªäº›é±¼ç¼¸éœ€è¦æ ‡è®°æˆ$M$, ä¸å†ä»…ä»…å–å†³äº$2a_i$ä¸$a_i + b_i - 1$çš„å¤§å°å…³ç³»äº†, ç©ºé±¼ç¼¸èƒ½å¯¹æˆ‘ä»¬çš„é€‰æ‹©è¿›è¡Œå½±å“. æ‰€ä»¥, è´ªå¿ƒçš„æ–¹æ³•ä¸å¯è¡Œ. å°è¯•ä¸€ä¸ªèƒ½å¤Ÿå¯¹æ¯”ä¸¤ç§å†³ç­–(æ ‡è®°æˆ$M$è¿˜æ˜¯$F$)çš„ä¼˜åŠ£æ€§çš„åšæ³• â€”â€” DP.

ä¸€æ­¥ä¸€æ­¥æ¥.

æˆ‘ä»¬ä¸éœ€è¦ç»™ç©ºé±¼ç¼¸æ ‡å·, æŠŠä»–å’Œéç©ºé±¼ç¼¸åˆ†ç¦»å¼€, $dp$çš„ç¬¬ä¸€ç»´åªè€ƒè™‘éç©ºé±¼ç¼¸.

ç”±äºç©ºé±¼ç¼¸çš„æ•°é‡ä¼šå¯¹ç»“æœé€ æˆå½±å“, æ‰€ä»¥åœ¨çŠ¶æ€ä¸­åŠ å…¥ç©ºé±¼ç¼¸.

$dp(i, j)$è¡¨ç¤ºå‰$i$ä¸ª(éç©º)é±¼ç¼¸, å¦å¤–æœ‰$j$ä¸ªç©ºé±¼ç¼¸è¢«**ä½¿ç”¨**, å³æœ‰$j$æ¡$M$ä¸­çš„é›„é±¼è¢«æ‹¿å‡ºæ¥ä¸”åˆ†åˆ«æ”¾åœ¨äº†ç©ºé±¼ç¼¸ä¸­.

å¦‚æœæ²¡æœ‰ç©ºé±¼ç¼¸, é±¼ç¼¸çš„æ ‡å·æ˜¯æœ‰é™åˆ¶æ¡ä»¶çš„, æ‰€ä»¥æˆ‘ä»¬éœ€è¦çŸ¥é“é±¼ç¼¸çš„æ ‡å·æƒ…å†µ. ä½†æ˜¯ä¸éœ€è¦çŸ¥é“å…·ä½“çš„æ ‡å·æƒ…å†µ, è€Œéœ€è¦çŸ¥é“**æœ‰æ²¡æœ‰**æ ‡å·ä¸º$F$çš„å’Œ**æœ‰æ²¡æœ‰**æ ‡å·ä¸º$M$çš„. æ‰€ä»¥, æˆ‘ä»¬é™„åŠ ä¸Šä¸¤ä¸ªçŠ¶æ€, åˆ†åˆ«è¡¨ç¤ºå‰$i$ä¸ªä¸­æœ‰æ— $F$, $M$. æœ€åçŠ¶æ€é•¿è¿™æ ·:

$$dp(i, j, 0 \/ 1, 0 \/ 1)$$

è¡¨ç¤ºå‰$i$ä¸ª(éç©º)é±¼ç¼¸ä¸­, ç§»åŠ¨äº†$j$æ¡é›„é±¼åˆ°$j$ä¸ªç©ºé±¼ç¼¸ä¸­, å‰$i$ä¸ªé±¼ç¼¸æœ‰/æ— $F$, å‰$i$ä¸ªé±¼ç¼¸æœ‰/æ— $M$

$dp$æ–¹ç¨‹è€é•¿è€é•¿äº†:

é¦–å…ˆè¾¹ç•Œæ¡ä»¶$dp(0, 0, 0, 0) = 0$, å…¶ä»–$dp(0, 0)$çš„ä¸å­˜åœ¨, å¯ç›´æ¥è®¾ä¸º`INF`. å½“$i>1$æ—¶, $dp(i, j, 0, 0)$ä¹Ÿä¸å­˜åœ¨, è®¾ä¸º`INF`.

$dp(i, j, 0, 1)$ ä»ä»¥ä¸‹çŠ¶æ€è½¬ç§»:

$$
\begin{aligned}
	&dp(i-1, j, 0, 1) + 2a_i &\text{ä¹‹å‰æœ‰M, å½“å‰ä¸ºM, ä¸ç§»åŠ¨åˆ°ç©º} \newline
	&dp(i-1, j, 0, 0) + 2a_i &\text{ä¹‹å‰æ— M, å½“å‰ä¸ºM, ä¸ç§»åŠ¨åˆ°ç©º} \newline
	&dp(i-1, max(0, j - a_i), 0, 1) + 2 * a_i - min(j, a_i) &\text{ä¹‹å‰æœ‰M, å½“å‰ä¸ºM, å…¨ç§»åŠ¨åˆ°ç©º} \newline
	&dp(i-1, max(0, j - a_i), 0, 0) + 2 * a_i - min(j, a_i) &\text{ä¹‹å‰æ— M, å½“å‰ä¸ºM, å…¨ç§»åŠ¨åˆ°ç©º}
\end{aligned}
$$

$dp(i, j, 1, 0)$ ä»ä»¥ä¸‹çŠ¶æ€è½¬ç§»:

$$
\begin{aligned}
	dp(i-1, j, 1, 0) + a_i + b_i - 1 \newline
	dp(i-1, j, 0 ,0) + a_i + b_i - 1
\end{aligned}
$$

_$F$ä¸­çš„é±¼ä¸éœ€è¦ç§»åˆ°ç©ºé±¼ç¼¸, åªæœ‰è¿™ä¸¤ä¸ªçŠ¶æ€éœ€è¦è½¬ç§»_

$dp(i, j, 1, 1)$ ä»ä»¥ä¸‹çŠ¶æ€è½¬ç§»:

$$
\begin{aligned}
	&dp(i-1, j, 1, 1) + 2 * a_i \newline
	&dp(i-1, max(0, j - a_i), 1, 1) + 2 * a_i - min(j, a_i) \newline
	&dp(i-1, j, 1, 1) + a_i + b_i - 1 \newline
	&dp(i-1, j, 1, 0) + 2 * a_i \newline
	&dp(i-1, max(0, j - a_i), 1, 0) + 2 * a_i - min(j, a_i) \newline
	&dp(i-1, j, 0, 1) + a_i + b_i - 1
\end{aligned}
$$

_~~å†™ä¸åŠ¨äº†~~æ–¹ç¨‹ä¸ä¸€ä¸€è§£é‡Šäº†, ä»£ç æ³¨é‡Šé‡Œæœ‰å†™._

æœ€å, å–ç­”æ¡ˆéœ€è¦åˆ†æƒ…å†µè®¨è®º:

æ²¡æœ‰ç©ºé±¼ç¼¸, é‚£ä¹ˆå¿…é¡»æ»¡è¶³"è‡³å°‘ä¸€ä¸ª$M$, ä¸€ä¸ª$F$"çš„æ¡ä»¶, æ‰€ä»¥ç­”æ¡ˆæ˜¯$dp(non\\_empty, 0, 1, 1)$

æœ‰ç©ºé±¼ç¼¸, æ²¡æœ‰é™åˆ¶æ¡ä»¶. æšä¸¾ç©ºé±¼ç¼¸çš„ä½¿ç”¨æ•°é‡, å¯¹$dp(non\\_empty, k, 0\/1, 0\/1), 0 \le k \le empty\\_tank$ å–minå°±æ˜¯ç­”æ¡ˆäº†.

å¤æ‚åº¦$O(n^2)$

ç»ˆäºå†™å®Œäº†...

æ€»ç»“ä¸€ä¸‹, ä¸ºä»€ä¹ˆæ²¡æœ‰æƒ³åˆ°è¿™æ ·çš„dp

é¦–å…ˆ, æ²¡æœ‰æƒ³åˆ°åªéœ€è¦ä¿å­˜"å‰$i$ä¸ªæ˜¯å¦æœ‰æ ‡å·ä¸º$M$æˆ–$F$"è¿™æ ·çš„çŠ¶æ€, å‚»ä¹ä¹åœ°ä¿å­˜å‰$i$ä¸ªæœ‰$j$ä¸ªæ ‡å·ä¸º$M$.

å…¶æ¬¡, æ²¡æœ‰æƒ³åˆ°æŠŠç©ºé±¼ç¼¸æ•°é‡ä¿å­˜åœ¨çŠ¶æ€é‡Œ. å¯èƒ½æ˜¯å—åˆ°ä¿å­˜äº†$M$çš„ä¸ªæ•°çš„å½±å“, å†åŠ ä¸€ç»´å°±ç‚¸äº†, æ‰€ä»¥æ ¹æœ¬æ²¡å¾€è¿™æ–¹é¢æƒ³.

{{% code %}}

_ç”±äºä¸€å¼€å§‹å¼€äº†LL, ç„¶åç‚¸ç©ºé—´äº†, æ‰€ä»¥$dp$æ»šäº†ç¬¬ä¸€ç»´. åæ¥å‘ç°æœ€å¤§å€¼ä¸ä¼šè¶…è¿‡int, äºæ˜¯æ”¹å›äº†int, ä½†æ˜¯æ»šåŠ¨æ•°ç»„ä¾ç„¶ä¿ç•™, æ²¡ç®—ä¸æ»šä¼šä¸ä¼šç‚¸._

```cpp
const int MAXN = 3e3+10;

int n, empty_tank, non_empty, a[MAXN], b[MAXN];
int dp[2][MAXN][2][2], male = 0;

int main() {
	scanf("%d", &n);
	for (int i = 1; i <= n; i++) {
		int x, y;
		scanf("%d%d", &x, &y);
		if (!x && !y)
			empty_tank++;
		else {
			a[++non_empty] = x;
			male += x;
			b[non_empty] = y;
		}
	}
	if (!male) {
		puts("0");
		return 0;
	}
	for (int i = 0; i <= empty_tank; i++) {
		dp[0][i][0][0] = dp[0][i][0][1] = dp[0][i][1][0] = dp[0][i][1][1] = INTINF;
		dp[1][i][0][0] = dp[1][i][0][1] = dp[1][i][1][0] = dp[1][i][1][1] = INTINF;
	}
	dp[0][0][0][0] = 0;
	for (int i = 1; i <= non_empty; i++) {
		for (int j = 0; j <= empty_tank; j++) {
			int cur = i&1;
			// åˆå§‹åŒ–
			dp[cur][j][0][0] = dp[cur][j][0][1] = dp[cur][j][1][0] = dp[cur][j][1][1] = INTINF;

			//è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯Fæˆ–è€…M, æ‰€ä»¥00ä¸å­˜åœ¨.
			dp[cur][j][0][0] = INTINF;

			int &dpij01 = dp[cur][j][0][1];
			// ä¹‹å‰æœ‰M, å½“å‰ä¸ºM, ä¸ç§»åŠ¨åˆ°ç©º
			dpij01 = min(dpij01, dp[cur^1][j][0][1] + 2 * a[i]);
			// ä¹‹å‰æ— M, å½“å‰ä¸ºM, ä¸ç§»åŠ¨åˆ°ç©º
			dpij01 = min(dpij01, dp[cur^1][j][0][0] + 2 * a[i]);
			// ä¹‹å‰æœ‰M, å½“å‰ä¸ºM, å…¨ç§»åŠ¨åˆ°ç©º
			dpij01 = min(dpij01, dp[cur^1][max(0, j - a[i])][0][1] + 2 * a[i] - min(j, a[i]));
			// ä¹‹å‰æ— M, å½“å‰ä¸ºM, å…¨éƒ¨ç§»åˆ°ç©º
			dpij01 = min(dpij01, dp[cur^1][max(0, j - a[i])][0][0] + 2 * a[i] - min(j, a[i]));

			int &dpij10 = dp[cur][j][1][0];
			// ç”±äºFç§»åŠ¨åˆ°ç©ºå’Œä¸ç§»åŠ¨åˆ°ç©ºçš„èŠ±è´¹ç›¸åŒ, ç§»åŠ¨çš„è¯æµªè´¹äº†ç©º, ä¸åˆ’ç®—, æ‰€ä»¥Fä¸ç§»åŠ¨åˆ°ç©º
			// ä¹‹å‰æœ‰F, å½“å‰ä¸ºF
			dpij10 = min(dpij10, dp[cur^1][j][1][0] + a[i] + b[i] - 1);
			// ä¹‹å‰æ— F, å½“å‰ä¸ºF
			dpij10 = min(dpij10, dp[cur^1][j][0][0] + a[i] + b[i] - 1);

			int &dpij11 = dp[cur][j][1][1];
			// ä¹‹å‰æœ‰Få’ŒM, å½“å‰ä¸ºM, ä¸ç§»åŠ¨åˆ°ç©º
			dpij11 = min(dpij11, dp[cur^1][j][1][1] + 2 * a[i]);
			// ä¹‹å‰æœ‰Få’ŒM, å½“å‰ä¸ºM, å…¨ç§»åŠ¨åˆ°ç©º
			dpij11 = min(dpij11, dp[cur^1][max(0, j - a[i])][1][1] + 2 * a[i] - min(j, a[i]));
			// ä¹‹å‰æœ‰Få’ŒM, å½“å‰ä¸ºF, ä¸ç§»åŠ¨åˆ°ç©º
			dpij11 = min(dpij11, dp[cur^1][j][1][1] + a[i] + b[i] - 1);
			// ä¹‹å‰æœ‰Fæ— M, å½“å‰ä¸ºM, ä¸ç§»åŠ¨åˆ°ç©º
			dpij11 = min(dpij11, dp[cur^1][j][1][0] + 2 * a[i]);
			// ä¹‹å‰æœ‰Fæ— M, å½“å‰ä¸ºM, å…¨ç§»åŠ¨åˆ°ç©º
			dpij11 = min(dpij11, dp[cur^1][max(0, j - a[i])][1][0] + 2 * a[i] - min(j, a[i]));
			// ä¹‹å‰æ— Fæœ‰M, å½“å‰ä¸ºF, ä¸ç§»åŠ¨åˆ°ç©º
			dpij11 = min(dpij11, dp[cur^1][j][0][1] + a[i] + b[i] - 1);
		}
	}
	int ans = INTINF;
	if (empty_tank)
		for (int i = 0; i <= empty_tank; i++) {
			ans = min(ans, dp[non_empty&1][i][0][0]);
			ans = min(ans, dp[non_empty&1][i][1][0]);
			ans = min(ans, dp[non_empty&1][i][0][1]);
			ans = min(ans, dp[non_empty&1][i][1][1]);
		}
	else
		ans = dp[non_empty&1][0][1][1];
	printf("%d\n", ans);
	return 0;
}
```
{{% /code %}}

## G. Getting Confidence

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/G)

$n \times n$çš„çŸ©é˜µ$M_{i, j}$, é€‰æ‹©$n$ä¸ªæ•°, è¦æ±‚æ¯è¡Œæ¯åˆ—åªæœ‰ä¸€ä¸ªè¢«é€‰ä¸­, ä¸”$n$ä¸ªæ•°çš„ä¹˜ç§¯æœ€å¤§. æ±‚é€‰äº†å“ªäº›æ•°(è¾“å‡ºç¬¬$i$åˆ—é€‰çš„æ˜¯ç¬¬å‡ ä¸ªæ•°)

$1 \le n \le 100$

#### é¢˜è§£

äºŒåˆ†å›¾çš„å¸¦æƒåŒ¹é…. è¡Œå’Œåˆ—åŒ¹é…, é€‰æ‹©çš„å°±æ˜¯å“ªè¡Œå“ªåˆ—çš„æ•°äº†.

ä¹˜ç§¯å–å¯¹æ•°, å°±æ˜¯æ±‚å’Œäº†.

æœ€å¤§å€¼å–ä¸ªç›¸åæ•°, å°±æ˜¯æœ€å°å€¼äº†.

æœ€å°è´¹ç”¨æœ€å¤§æµ.

å¤æ‚åº¦$O($èƒ½è¿‡$)$

{{% code %}}

```cpp
const int maxn = 210;
const int maxm = 3e4 + 10;

int n, s, t;

struct Edge {
	int to, next, cap, flow;
	LD cost;
} edges[maxm];
int head[maxn], mm = 0;

void AddEdge(int u, int v, int cap, LD cost) {
	edges[mm] = Edge{v, head[u], cap, 0, cost};
	head[u] = mm++;
}

void AddNet(int u, int v, int cap, LD cost) {
	AddEdge(u, v, cap, cost);
	AddEdge(v, u, 0, -cost);
#ifdef D
	printf("(%d, %d), cap = %d, cost = %Lf\n", u, v, cap, cost);
#endif
}

LD d[maxn];
int inq[maxn], p[maxn], a[maxn];
bool EK(int &flow, LD &cost) {
	for (int i = 1; i <= 2*n+2; i++)
		d[i] = INTINF;
	queue<int> q;
	q.push(s), d[s] = 0;
	inq[s] = 1, p[s] = -1, a[s] = INTINF;
	while (!q.empty()) {
		int u = q.front();
		q.pop(), inq[u] = 0;
		for (int i = head[u]; ~i; i = edges[i].next) {
			Edge &e = edges[i];
			if (d[e.to] > d[u] + e.cost && e.cap > e.flow) {
				d[e.to] = d[u] + e.cost;
				a[e.to] = min(a[u], e.cap - e.flow);
				p[e.to] = i;
				if (!inq[e.to])
					q.push(e.to), inq[e.to] = 1;
			}
		}
	}
	if (d[t] >= INTINF)
		return false;
	flow += a[t];
	cost += a[t] * d[t];
	for (int i = p[t]; ~i; i = p[edges[i^1].to]) {
		edges[i].flow += a[t];
		edges[i^1].flow -= a[t];
	}
	return true;
}

int main() {
	scanf("%d", &n);
	memset(head, -1, sizeof(head));
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++) {
			int p;
			scanf("%d", &p);
			AddNet(i, j+n, 1, -log(p));
		}
	s = 2*n + 1, t = s + 1;
	for (int i = 1; i <= n; i++) {
		AddNet(s, i, 1, 0);
		AddNet(i+n, t, 1, 0);
	}
	int flow = 0;
	LD cost = 0;
	while (EK(flow, cost));
	for (int u = 1+n; u <= 2*n; u++)
		for (int i = head[u]; ~i; i = edges[i].next) {
			Edge &e = edges[i];
			if (e.flow && e.to != t) {
				printf("%d ", e.to);
				break;
			}
		}
	puts("");
	return 0;
}
```
{{% /code %}}

## H. Hour for a Run

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/H)

è·‘æ­¥, æ€»å…±è·‘$v$åœˆ. æ¯åœˆæœ‰$n$ä¸ªæ ‡è®°, æ±‚è·‘å®Œ$p\\%$æ—¶, è‡³å°‘éœ€è¦ç»è¿‡å‡ ä¸ªæ ‡è®°. å¯¹äº$p = 10, 20, \dots 80, 90$è¾“å‡º$9$ä¸ªç­”æ¡ˆ.

$1 \le v, n \le 10^4$

#### é¢˜è§£

æ°´é¢˜, $\lceil \frac{vnp}{100} \rceil$.

å¤æ‚åº¦$O(1)$

{{% code %}}

```cpp
int v, n;

int main() {
	scanf("%d%d", &v, &n);
	int sum = v * n;
	for (int i = 1; i < 10; i++)
		printf("%d ", (int)ceil(1.0 * sum * i / 10));
	puts("");
	return 0;
}
```
{{% /code %}}

## I. Interplanetary

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/I)

$n$ä¸ªç‚¹$m$æ¡è¾¹, æ¯ä¸ªç‚¹æœ‰ç‚¹æƒ$t_i$, æ¯æ¡è¾¹æœ‰è¾¹æƒ$d_i$. $q$ä¸ªè¯¢é—®å¦‚ä¸‹ `a b k op`, è¡¨ç¤ºè¯¢é—®ä¸€æ¡$a$åˆ°$b$çš„æœ€çŸ­è·¯, ä¸”æ»¡è¶³è·¯å¾„ä¸Š(é™¤ç«¯ç‚¹)çš„ç‚¹æƒå°äºç­‰äºæ‰€æœ‰ç‚¹ç‚¹æƒçš„ç¬¬$k$å°(æˆ–å¤§äºç¬¬$k$å¤§), å½“ `op` ä¸º$0$æ—¶è¡¨ç¤ºç¬¬kå°, $1$è¡¨ç¤ºç¬¬$k$å¤§.

å…¶ä¸­$k$å°/å¤§æ˜¯å»é‡ä»¥åçš„. ($k$å¯èƒ½å¤§äºå»é‡ä»¥åçš„ç‚¹æƒæ€»æ•°.)

$1 \le n \le 400, 0 \le m \le \frac{n(n-1)}{2}, -10^9 \le t_i \le 10^9, 1 \le q \le 10^5$

#### é¢˜è§£

æœ€çŸ­è·¯é—®é¢˜, ä¸”$n$å¾ˆå°, è‡ªç„¶å°è¯•Floyd.

å’Œ[ç¾åé‡å»º](https://www.luogu.com.cn/problem/P1119)å¾ˆåƒ, æˆ‘ä»¬æŠŠè¯¢é—®ç¦»çº¿, ç„¶åå°±å¯ä»¥åœ¨Floydçš„è¿‡ç¨‹ä¸­æ›´æ–°å¯¹åº”çš„ç­”æ¡ˆäº†.

ä»¥$k$å°ä¸ºä¾‹, å…ˆå¯¹è¯¢é—®é€’å¢æ’åº, å†å¯¹ç‚¹çš„æƒå€¼é€’å¢æ’åº, æŒ‰ç…§æ’åºä»¥åçš„é¡ºåºæšä¸¾æœ€å¤–å±‚çš„ç‚¹(Floydä¸­é—´ç‚¹). è¿™æ ·åšå®Œè¿™ä¸ªä¸­é—´ç‚¹ä»¥å, å·²ç»åŠ å…¥çš„ç‚¹(ç”¨æ¥æ›´æ–°çš„ä¸­é—´ç‚¹)æƒå€¼ä¸€å®šä¸æ¯”å½“å‰ä¸­é—´ç‚¹å¤§, å¹¶ä¸”æ¯”å½“å‰ä¸­é—´ç‚¹å¤§çš„ç‚¹éƒ½æ²¡æœ‰åŠ å…¥. æ‰€ä»¥, æˆ‘ä»¬åœ¨è¿™å¼ "ä¸´æ—¶"çš„å›¾ä¸Šå¯¹"è·¯å¾„ä¸Šçš„ç‚¹æƒå°äºç­‰äº"è¿™ä¸ªä¸­é—´ç‚¹çš„æƒå€¼çš„è¯¢é—®è¿›è¡ŒæŸ¥è¯¢. $k$å¤§åè¿‡æ¥åšä¸€éå³å¯.

{{% code %}}

```cpp
const int MAXN = 4e2+10;
const int MAXQ = 1e5+10;

struct QLow {
	int id, a, b;
};
vector<QLow> qlow[MAXN];

struct QHigh {
	int id, a, b;
};
vector<QHigh> qhigh[MAXN];

struct Planet {
	int id, t;
	bool operator < (const Planet &P) const {
		return t == P.t ? id < P.id : t < P.t;
	}
} planets[MAXN];

int n, m, q, G[MAXN][MAXN], tmp[MAXN][MAXN], ans[MAXQ];

int main() {
	// freopen("in", "r", stdin);
	scanf("%d%d", &n, &m);
	for (int i = 1; i <= n; i++) {
		planets[i].id = i;
		scanf("%d", &planets[i].t);
	}
	sort(planets + 1, planets + 1 + n);
	for (int i = 1; i <= n; i++)
		for (int j = 1; j <= n; j++)
			G[i][j] = i == j ? 0 : INTINF;
	for (int i = 1; i <= m; i++) {
		int x, y, d;
		scanf("%d%d%d", &x, &y, &d);
		G[x][y] = G[y][x] = min(d, G[x][y]);
	}
	scanf("%d", &q);
	for (int i = 1; i <= q; i++) {
		int a, b, k, t, cnt = 0;
		scanf("%d%d%d%d", &a, &b, &k, &t);
		if (t) {
			for (int j = n; j; j--) {
				while (j > 1 && planets[j].t == planets[j-1].t)
					j--;
				if (++cnt >= k) {
					qhigh[j].push_back(QHigh{i, a, b});
					break;
				}
			}
			// å‡ºé¢˜äººä¸è®²æ­¦å¾·, kä¼šå¤§äºå»é‡åçš„æ€»æ•°
			// å¦‚æœä¸åŠ ä¸‹é¢çš„è¯ä¼šWA31
			if (cnt < k)
				qhigh[1].push_back(QHigh{i, a, b});
		}
		else {
			for (int j = 1; j <= n; j++) {
				while (j < n && planets[j].t == planets[j+1].t)
					j++;
				if (++cnt >= k) {
					qlow[j].push_back(QLow{i, a, b});
					break;
				}
			}
			if (cnt < k)
				qlow[n].push_back(QLow{i, a, b});
		}
	}
	memset(ans, INTINF, sizeof(ans));
	memcpy(tmp, G, sizeof(G));
	for (int k = 1; k <= n; k++) {
		int id = planets[k].id;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				tmp[i][j] = tmp[j][i] = min(tmp[i][j], tmp[i][id] + tmp[id][j]);
		for (auto x : qlow[k])
			ans[x.id] = tmp[x.a][x.b];
	}
	memcpy(tmp, G, sizeof(G));
	for (int k = n; k; k--) {
		int id = planets[k].id;
		for (int i = 1; i <= n; i++)
			for (int j = 1; j <= n; j++)
				tmp[i][j] = tmp[j][i] = min(tmp[i][j], tmp[i][id] + tmp[id][j]);
		for (auto x : qhigh[k])
			ans[x.id] = tmp[x.a][x.b];
	}
	for (int i = 1; i <= q; i++)
		printf("%d\n", ans[i] < INTINF ? ans[i] : -1);
	return 0;
}
```
{{% /code %}}

## J. Jar of Water Game

#### [é¢˜ç›®](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/J)

$n$ä¸ªäººå›´ä¸€åœˆæ‰“ç‰Œ. è§„åˆ™å¦‚ä¸‹:

- ç‰Œçš„å¤§å°å¦‚ä¸‹ "$A23456789DQJK$".
- æ¯ä¸ªäººå¼€å§‹æŠ½$4$å¼ ç‰Œ, éšæœºé€‰ä¸€ä¸ªäººå…ˆæ‰‹, å¤šç»™ä¸€å¼ ç‰Œ"Wild"(æ²¡äººè¦çš„é‡ç‰Œ).
- è½®åˆ°æŸä¸ªäºº, å¦‚æœä»–æ‰‹ä¸Šæœ‰"Wild"ä¸”ä¸æ˜¯åˆšåˆšå¾—åˆ°(å…ˆæ‰‹ç¬¬ä¸€æ¬¡å¾—åˆ°çš„"Wild"ä¹Ÿç®—åˆšåˆšå¾—åˆ°), åˆ™æŠŠ"Wild"ç»™ä¸‹å®¶; å¦åˆ™, ä»–é€‰æ‹©æ‰‹ä¸Šå‡ºç°æ¬¡æ•°æœ€å°‘çš„ç‰Œä¸­çš„æŸä¸€å¼ ä¼ ç»™ä¸‹å®¶, å¦‚æœæœ‰å‡ºç°æ¬¡æ•°ç›¸åŒçš„ç‰Œ, åˆ™é€‰æ‹©ç‚¹æ•°å°çš„.
- å½“ä¸€ä¸ªäººä¼ å®Œäº†ç‰Œä»¥å, è½®åˆ°ä¸‹å®¶ä¼ .

å®šä¹‰"è·èƒœçŠ¶æ€"ä¸ºæ‰‹ä¸Šæœ‰ä¸”ä»…æœ‰$4$å¼ ç‚¹æ•°ç›¸ç­‰çš„ç‰Œ.

å½“ä¼ å®Œç‰Œä¹‹å, å¯èƒ½ä¼šäº§ç”Ÿè‹¥å¹²ä¸ª"è·èƒœçŠ¶æ€"çš„äºº. å¦‚æœåªæœ‰ä¸€ä¸ªäººæ˜¯"è·èƒœçŠ¶æ€", åˆ™ä»–èµ¢, æ¸¸æˆç»“æŸ; å¦‚æœæœ‰å¤šä¸ªäººæ˜¯"è·èƒœçŠ¶æ€", åˆ™æ‰‹ç‰Œç‚¹æ•°å°çš„äººèµ¢, æ¸¸æˆç»“æŸ.

ç»™å‡º$n$ä¸ªäººçš„åˆå§‹æ‰‹ç‰Œå’Œå…ˆæ‰‹$k$, æ±‚æœ€åè·èƒœçš„æ˜¯è°.

$2 \le n \le 13$

#### é¢˜è§£

æ¨¡æ‹Ÿå³å¯.

ç”¨ `set` ä¿å­˜æ‰‹ç‰Œ, èŠ‚ç‚¹ç»“æ„ä½“å«æœ‰æŸç§ç‰Œçš„ç‚¹æ•°å’Œæ•°é‡æ•°, æŒ‰ç…§æ•°é‡é€’å¢, ç‚¹æ•°é€’å¢æ’åº, é‚£ä¹ˆ `set` é‡Œçš„ç¬¬ä¸€ä¸ªå°±æ˜¯è¦ç»™ä¸‹å®¶çš„ç‰Œäº†.

å¯¹äº"Wild", æŠŠä»–çœ‹æˆä¸¤ç§, ä¸€ç§æ˜¯åˆšæ‹¿åˆ°, ä¸èƒ½æ‰“. é‚£ä¹ˆè®¾ç½®ä»–çš„"æ•°é‡"ä¸º$6$(åªè¦æ¯”$4$å¤§å°±è¡Œ), ä»–å°±æ’åœ¨äº†æœ€åé¢; å¦ä¸€ç§æ˜¯(ä¸‹ä¸€è½®)é©¬ä¸Šæ‰“å‡º, é‚£ä¹ˆè®¾ç½®ä»–çš„"æ•°é‡"ä¸º$0$, ä»–å°±æ’åœ¨äº†æœ€å‰é¢.

åˆšæ‹¿åˆ°"Wild", è®¾ä¸ºç¬¬ä¸€ç§, æ‰“å®Œå…¶ä»–ç‰Œä»¥å, åˆ é™¤ç¬¬ä¸€ç§"Wild"(æœ€åä¸€ä¸ªç‚¹), å†æ’å…¥ç¬¬äºŒç§"Wild".

è¯¦è§ä»£ç .

å…³äº `set` çš„åˆ é™¤æ“ä½œ:

`auto x`, `x` æ˜¯"å‰¯æœ¬", ä¸èƒ½ç›´æ¥ä¿®æ”¹. ä»–ä¸æ˜¯è¿­ä»£å™¨, å¯ä»¥ç›´æ¥ `erase(x)`.

æ’å…¥:

> todo

å¤æ‚åº¦æ˜¯ç„å­¦.

{{% code %}}

```cpp
const int maxn = 20;
int VAL[300];

struct Node {
	int val, cnt;
	bool operator < (const Node &N) const {
		return cnt == N.cnt ? val < N.val : cnt < N.cnt;
	}
};

int n, k;
char str[maxn];
set<Node> cards[maxn];

// ç¬¬ä¸€æ¬¡wild ä¸º val = 14, cnt = 6
// ç¬¬äºŒæ¬¡wild ä¸º val = 0, cnt = 0

void Insert(int id, int val) {
	if (val == 0) {
		cards[id].insert(Node{VAL[1], 6});
		return;
	}
	int app = 0;
	// å¦‚æœæœ‰, åˆ™æ¬¡æ•°åŠ ä¸€
	for (auto nd : cards[id]) {
		if (nd.val == val) {
			cards[id].erase(nd);
			nd.cnt++;
			cards[id].insert(nd);
			app = 1;
			break;
		}
	}
	// æ²¡æœ‰, åˆ™æ–°å»º
	if (!app)
		cards[id].insert(Node{val, 1});
}

void Erase(int id, int val) {
	for (auto nd : cards[id])
		if (nd.val == val) {
			cards[id].erase(nd);
			nd.cnt--;
			if (nd.cnt > 0)
				cards[id].insert(nd);
			break;
		}
}

int main() {
	for (int i = 2; i <= 9; i++)
		VAL[i+'0'] = i;
	VAL['A'] = 1, VAL['D'] = 10, VAL['Q'] = 11, VAL['J'] = 12, VAL['K'] = 13, VAL[1] = 14, VAL[2] = 0;
	scanf("%d%d", &n, &k);
	for (int i = 1; i <= n; i++) {
		scanf("%s", str);
		for (int j = 0; str[j]; j++) {
			int val = VAL[str[j]];
			Insert(i, val);
		}
	}
	cards[k].insert(Node{VAL[1], 6});

	int cur = k, nxt = cur % n + 1;
	while (1) {
		set<Node>::iterator it = cards[cur].begin();
		Erase(cur, (*it).val);		// cur å‡å»ä¸€å¼ ç‰Œ
		Insert(nxt, (*it).val);	// nxt åŠ ä¸Šä¸€å¼ ç‰Œ
		// åˆ¤æ–­æœ€åä¸€ä¸ªç‚¹æ˜¯ä¸æ˜¯wild, æ˜¯çš„è¯æ”¹ä¸€ä¸‹
		it = cards[cur].end();
		--it;
		if ((*it).val == VAL[1]) {
			cards[cur].erase(it);
			cards[cur].insert(Node{VAL[2], 0});
		}

		int winner = 0, winner_val = 20;
		for (int i = 1; i <= n; i++) {
			if (cards[i].size() == 1) {
				it = cards[i].begin();
				if ((*it).cnt == 4) {
					if ((*it).val < winner_val) {
						winner_val = (*it).val;
						winner = i;
					}
				}
			}
		}
		if (winner) {
			printf("%d\n", winner);
			break;
		}
		cur = nxt;
		nxt = cur % n + 1;
	}
	return 0;
}
```
{{% /code %}}

## K

## L. Less Coin Tosses

#### [é¢˜æ„](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/L)

(ç”±äºé¢˜é¢å¤ªé˜´é—´, ç”šè‡³çœ‹ä¸æ‡‚, æ‰€ä»¥ç›´æ¥å»ºæ¨¡å§)

æ±‚ $\sum_{i=0}^n \tbinom{n}{i} \mod 2$

$2 \le n \le 10^{18}$

#### é¢˜è§£

ç»„åˆæ•°å–æ¨¡, æƒ³åˆ° Lucas å®šç†.

[Lucas å®šç†](https://brilliant.org/wiki/lucas-theorem/):

$$\tbinom{n}{m} \equiv \Pi \tbinom{n_i}{m_i} \mod p$$

å…¶ä¸­ $p$ æ˜¯ä¸€ä¸ªè´¨æ•°, $n_i, m_i$ æ˜¯ $p$ è¿›åˆ¶ä¸‹çš„å„ä½:

$$n = n_k p^k + n_{k-1} p^{k-1} + \dots + n_2 p^2 + n_1 p^1 + n_0 p^0$$

$$m = m_k p^k + m_{k-1} p^{k-1} + \dots + m_2 p^2 + m_1 p^1 + m_0 p^0$$

è¿™é“é¢˜ä¸­, $p=2$, å¯¹äºä¸€ä¸ªç»™å®šçš„$n$, æƒ³çŸ¥é“æœ‰å¤šå°‘ä¸ª$m, 0 \le m \le n$ æ»¡è¶³$\tbinom{n}{m} \equiv \Pi \tbinom{n_i}{m_i} \equiv 1 \mod 2$. è¦æ»¡è¶³ä»¥ä¸Šæ¡ä»¶, åˆ™éœ€è¦$\forall \tbinom{n_i}{m_i} \equiv 1 \mod 2$. æˆ‘ä»¬çŸ¥é“

$$\tbinom{0}{1} = 0, \tbinom{0}{0} = 1, \tbinom{1}{1} = 1, \tbinom{1}{0} = 1$$

æ‰€ä»¥å¯¹$n$å’Œ$m$äºŒè¿›åˆ¶åˆ†è§£, å…¶ä¸­$n$ä¸º$0$çš„ä½å¯¹åº”çš„$m$çš„ä½ä¸Šä¸èƒ½ä¸º1, åªèƒ½ä¸º0; $n$ä¸º$1$çš„ä½å¯¹åº”çš„$m$çš„ä½ä¸Šå¯ä»¥ä¸º$0$ä¹Ÿå¯ä»¥ä¸º$1$. ä¹Ÿå°±æ˜¯è¯´, å¯¹äº$n$ä¸º$1$çš„ä½, $m$çš„ä½å¯ä»¥æœ‰ä¸¤ç§é€‰æ‹©. æ¯ä¸€ä½çš„é€‰æ‹©ç›¸äº’ç‹¬ç«‹, ä¹˜æ³•åŸç†. æ‰€ä»¥, è®¾ count(n) ä¸º $n$çš„äºŒè¿›åˆ¶åˆ†è§£ä¸‹$1$çš„ä¸ªæ•°, åˆæ³•çš„$m$çš„ä¸ªæ•°ä¸º: $2^{count(n)}$

å¤æ‚åº¦$O(logn)$

{{% code %}}

```cpp
LL n;

LL count(LL x) {
	LL res = 0;
	while (x) {
		x -= lowbit(x);
		res++;
	}
	return res;
}

int main() {
	scanf("%lld", &n);
	LL p = count(n);
	printf("%lld\n", 1ll << p);
	return 0;
}
```
{{% /code %}}

## M. Maratona Brasileira de Popcorn

#### [é¢˜æ„](https://codeforces.com/group/2l2uaz0vCx/contest/102346/problem/M)

è¿ç»­æ”¾äº†$n$è¢‹çˆ†ç±³èŠ±, æ¯è¢‹é‡Œæœ‰$p_i$ä¸ª, æœ‰$c$ä¸ªäººåƒè¿™äº›çˆ†ç±³èŠ±. åƒçš„è§„åˆ™å¦‚ä¸‹:

- ä¸€ä¸ªäººä¸€æ¬¡åªèƒ½åƒè¿ç»­çš„æ ‡å·è¢‹å­é‡Œçš„çˆ†ç±³èŠ±
- ä¸€æ—¦æŸè¢‹çˆ†ç±³èŠ±è¢«æŸä¸ªäººåƒäº†, è¿™è¢‹çˆ†ç±³èŠ±ä¸èƒ½ç”±å…¶ä»–äººåƒ
- ä¸€ä¸ªäººä¸€æ¬¡ä¸èƒ½åƒè¶…è¿‡$t$ä¸ªçˆ†ç±³èŠ±
- ä¸€ä¸ªäººåƒä¸€æ¬¡çš„ç”¨æ—¶ä¸º$1$
- $c$ä¸ªäººå¯ä»¥åŒæ—¶å¼€å§‹åƒ, ä¸”å¯ä»¥åƒ$0$ä¸ª

é—®åƒå®Œçš„æœ€å°‘ç”¨æ—¶.

$1 \le n \le 10^5, 1 \le c \le 10^5, 1 \le t \le 50, 1 \le p_i \le 10^4$

#### é¢˜è§£

äºŒåˆ†ç­”æ¡ˆ$s$(æˆ‘ä¹Ÿä¸çŸ¥é“ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆæƒ³). ç„¶åä¸€ä¸ªäººæœ€å¤šåƒçš„ä¸ªæ•°å°±æ˜¯$st$, åˆç”±äºè¦åƒè¿ç»­çš„, å°±å¯ä»¥æŒ‰é¡ºåºè´ªå¿ƒå–$\sum p$, ä¿è¯å…¶å°äº$st$ä¸”æœ€å¤§. åšå®Œä¸€ä¸ªäººå°±è®¡æ•°åŠ ä¸€, åˆ¤æ–­èƒ½å¦ä¸è¶…è¿‡$c$ä¸ªäººåšå®Œæ‰€æœ‰çš„$p$.

å¤æ‚åº¦$O(nlognp)$

{{% code %}}

```cpp
const int MAXN = 1e5+10;

int n, c, t, p[MAXN];

bool Check(LL s) {
	LL up = s * t;
	int last = 0, cnt = 0;
	for (int i = 1; i <= n; i++) {
		if (p[i] - p[last] > up) {
			if (++cnt == c)
				return false;
			last = --i;
		}
	}
	return true;
}

int main() {
	scanf("%d%d%d", &n, &c, &t);
	for (int i = 1; i <= n; i++) {
		scanf("%d", p + i);
		p[i] += p[i-1];
	}
	int l = 0, r = INTINF, ans = -1;
	while (l <= r) {
		int mid = (l + r) >> 1;
		if (Check(mid)) {
			ans = mid;
			r = mid - 1;
		}
		else
			l = mid + 1;
	}
	printf("%d\n", ans);
	return 0;
}
```
{{% /code %}}
