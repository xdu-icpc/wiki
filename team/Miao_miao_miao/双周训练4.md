---
title: 双周训练4
description: 
published: true
date: 2020-11-09T17:17:37.060Z
tags: 
editor: markdown
dateCreated: 2020-11-08T09:49:41.576Z
---

# 双周训练4
## vp
fxq开场看了M，二分答案，读题读错细节wa，改了之后过了。
fxq写A，最开始考虑的是否有些探测器连起来可以把矩阵横向切开或者纵向切开，直接枚举所有探测器两次，写了个记忆化搜索，wa，后来发现少考虑了两种情况，从左边界出发到上边界，以及从下边界出发到右边界，加了之后过了。
lxy开场签了B，H，然后开始看L，读题后推了公式ans = $Σ_{i=0}^nC_n^i \%2$,然后打表找规律懵逼一万年后找到规律a掉，再去和hyk看D，卡了1h后lxy提出用两个优先队列一个记录叶子节点s另一个记录加入的答案q，每次从s中取出更新答案并标记路径，然后a掉，之后一起对着G发呆，lxy呆不下去了看到J过的挺多去看J，啊，是大模拟！！！终于再4：57压线a掉
## 补题
fxq:G
lxy:G
hyk:暂未补题
## G
乘积可以通过取对数操作转化成加法，进行带权二分图最优匹配，二分图左边$n$个点代表行，右边$n$个点代表列，每个数根据所在行列连边，跑一边KM算法，时间复杂度$O(n^3)$
```
#include<iostream>
#include<cstdio>
#include<vector>
#include<stack>
#include<queue>
#include<set>
#include<map>
#include<cstring>
#include<string>
#include<sstream>
#include<cmath>
#include<ctime>
#include<climits>
#include<algorithm>
#define LL long long
#define ULL unsigned long long
#define PII pair<int,int>
#define PLL pair<LL,LL>
#define PLI pair<LL,int>
#define pi acos(-1.0)
#define eps 1e-6
#define lowbit(x) x&(-x)
using namespace std;

const int maxn=110;

int n,a[maxn][maxn],match[maxn];
double g[maxn][maxn],ex1[maxn],ex2[maxn],slack[maxn];    
bool vis1[maxn],vis2[maxn];

bool dfs(int x){
    vis1[x]=true;
    for(int y=1;y<=n;y++) {
        if(vis2[y]) continue; 
        double gap=ex1[x]+ex2[y]-g[x][y];
        if(gap<eps){  
            vis2[y]=true;
            if(match[y]==-1 || dfs(match[y])){   
                match[y]=x;
                return true;
            }
        } 
        else{
            slack[y]=min(slack[y],gap);  
        }
    }
    return false;
}

void KM(){
    memset(match,-1,sizeof(match));    
    for(int i=1;i<=n;i++) ex2[i]=0;  
    for(int i=1;i<=n;i++) {
        ex1[i]=g[i][1];
        for(int j=2;j<=n;j++) {
            ex1[i]=max(ex1[i],g[i][j]);
        }
    }
    for(int i=1;i<=n;i++) {
        for(int i=1;i<=n;i++) slack[i]=1e9; 
        while(1){
            for(int i=1;i<=n;i++) vis1[i]=vis2[i]=0;
            if(dfs(i)) break;
            double d=1e9;
            for(int j=1;j<=n;j++)
                if(!vis2[j]) d=min(d,slack[j]);
            for(int j=1;j<=n;j++){
                if(vis1[j]) ex1[j]-=d;
                if(vis2[j]) ex2[j]+=d;
                else slack[j]-=d;
            }
        }
    }
    for(int i=1;i<n;i++){
        printf("%d ",match[i]);
    }
    printf("%d\n",match[n]);
}

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            scanf("%d",&a[i][j]);
            double x=a[i][j];
            g[i][j]=log(x);
        }
    }
    KM();
}
```