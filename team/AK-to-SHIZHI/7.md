---
title: 第 7 次双周训练
description: 
published: true
date: 2020-12-26T08:32:00.290Z
tags: 
editor: markdown
dateCreated: 2020-12-24T05:49:38.171Z
---

# VP
## D-Bits Reverse
给你两个数字x、y，每次可以对x在2进制下，任意的相邻的3个位置进行操作，使得中间的位置上的数字不变，两侧的两个位置上的数字交换。

问最少操作多少次，可以使得x变成y。

签到题，对奇数位和偶数位分类讨论即可。若x和y的奇数位和偶数位上1的数量不同，则无解；否则一定有解，且ans就是1的位置之差。

1mszs在计算ans的时候，枚举偶数位时，手误打成了odd.size()，然后WA了一发不知道为啥。lincong接手代码之后，找到问题并修正后AC。
## J-stone Game
有n堆石子，保证相邻两堆不等。A和B玩游戏，轮流从这n堆中，任意拿走一颗石子，但需要保证拿走第k堆的一颗石子后，第k堆的石子数量不能和它相邻的两堆相等。无法拿石子者输，问谁能赢？

显然，石子数量的单调性不会发生改变，所以能拿走的石子数量就是：保证序列单调性不变的前提下，尽量多的减少序列的值。

那么，我们只需找到序列的极小值和极大值的位置，先将所有的极小值都设为0，然后从极小值的位置开始向两边走，令每一个数等于前一个数+1，这样就可以在保证序列单调性不变的前提下，使得序列的值最小。

特殊地，极大值的位置会被走到2次，那么将极大值设为两次走到时的最大值即可。

最后，我们只需计算一下修改后的数列与原先的数列的差，这个差值就是能拿走的石子数num。如果num是奇数，则A赢，否则B赢。
## G-Greatest Common Divisor
给你n个数，每次操作可以让这n个数+1，问最少操作多少次，可以使得这n个数的gcd>1。

注意到，每次操作不会改变这n个数之间的差值，因此如果这n个数的gcd>1，那么它们的差值的gcd也必然>1。

因此，我们只需计算一下这n个数的差值的gcd，若gcd等于1，则无解（这n个数都等于1时除外）；若gcd>1，就枚举这n个数，用gcd的因子来计算操作次数，找到最小的那个即可。

代码如下：

	ll ans=2e15,tot=0;
	for(ll i=2;i*i<=p;i++)//p是这n个数的差值的gcd
	  if(p%i==0)
	    ys[++tot]=i,ys[++tot]=p/i;//ys数组记录gcd的因数
	if(!tot)  ys[++tot]=p;
	for(int i=0;i<a.size();i++)//枚举这n个数  
	  for(int j=1;j<=tot;j++)//枚举每一个因数
	  {
	    if(a[i]%ys[j]==0)  ans=0;
	    else  ans=min(ans,ys[j]-a[i]%ys[j]);//计算操作次数	
	  }
特殊地，当这n个数全部相等时，如果这n个数都等于1，那么操作1次即可；如果这n个数都>1，那么无需任何操作。

由于H题从头调到尾都没能调出来，所以3题滚粗。
# 补题
## H-Hamming Distance
给你两个长度一样的字符串s、t，构造一个字符串str，使得str与s对应位置字母不同的数量，等于str与t对应位置字母不同的数量（若有多个str满足题意，输出字典序最小的那个）。

一开始lincong以为是个简单的贪心，先将目标字符串全部置为a，然后从后向前替换，结果交上去WA了才意识到事情并没有那么简单。

后来手算了几组数据，发现这种情况没有考虑到：

aab
bba

如果直接贪心的话，会输出aca，但是显然正确答案是abc。相当于本来t串中的a就少，还要扔掉那个a换成c，但是接下来再给一个b就可以直接抹平s和t的差距，同时还能保证字典序最小。

考虑这种情况的存在，lincong就想着是不是得从前向后替换，然后发现不知怎样判断一个位置是否应该修改，最后一直调到VP结束也没能调出来。

VP结束后，lincong补题时发现，确实是应该正着构造，但是得开一个sum数组来记录每个位置向后最多可以调整的数量，这样就可以很好地解决VP时遇到的问题。

具体来说，我们正向构造，对于每一个位置，在保证后面可以调整回来的前提下（通过sum数组来判断），优先考虑a，接着考虑b，最后考虑其他字母。

代码如下：

    string work(string s,string t)
    {
      string q;//构造的字符串q 
	  int n=s.size();
  	  sum[n]=0;
  	  for(int i=n-1;i>=0;i--)
  	  {
    	sum[i]=sum[i+1];
    	if(s[i]!=t[i])  sum[i]++;//计算每个位置最多可以调整的数量 
  	  }
  	  int cnt=0;//same(q,s)-same(q,t),构造第i位的时候必须保证abs(cnt)<=sum[i+1] 
  	  for(int i=0;i<n;i++)
      {
	    if(s[i]==t[i]||abs(cnt)<sum[i+1])//s与t字符相同or后面可以调整回来 
		{
	  	  q+='a';
	  	  if(s[i]=='a'&&t[i]!='a')  cnt++;//与s相同的变多了,并且可以保证abs(cnt)<=sum[i+1] 
	  	  if(s[i]!='a'&&t[i]=='a')  cnt--;//与t相同的变多了,并且可以保证abs(cnt)<=sum[i+1] 
	  	  continue;
		}
		char c=min_char(s[i],t[i]);//计算与s[i]和t[i]都不相同的第一个字符 
		if(c=='a')
		{
	  	  if(abs(cnt)<=sum[i+1])  q+='a';//后面可以调整回来,优先考虑a,此时cnt不发生变化 
	  	  else if(cnt>0)  q+=t[i],cnt--;//后面调整不回来了,且现在与s相同的更多,所以放一个和t一样的 
	  	  else  q+=s[i],cnt++;//后面调整不回来了,且现在与t相同的更多,所以放一个和s一样的 
    	}
		else if(c=='b')
		{
	  	  if((s[i]=='a'&&cnt<sum[i+1])||(t[i]=='a'&&cnt>-sum[i+1]))//后面可以调整回来,优先考虑a 
	  	  {
	    	q+='a';
			if(s[i]=='a')  cnt++;
			else  cnt--;
	  	  }
	  	  else if(abs(cnt)<=sum[i+1])  q+='b';//后面可以调整回来,接着考虑b 
	  	  else//后面调整不回来了 
	  	  {
	    	if(s[i]=='a')  q+=t[i],cnt--;//此时一定是cnt>sum[j+1] 
	    	else  q+=s[i],cnt++;//此时一定是cnt<-sum[j+1] 
	  	  }
		}
		else
		{
	  	  if((s[i]=='a'&&cnt<sum[i+1])||(t[i]=='a'&&cnt>-sum[i+1]))//后面可以调整回来,优先考虑a 
	  	  {
			q+='a';
			if(s[i]=='a')  cnt++;
			else  cnt--;
	  	  }
	  	  else if((s[i]=='b'&&cnt<sum[i+1])||(t[i]=='b'&&cnt>-sum[i+1]))//后面可以调整回来,接着考虑b 
	  	  {
			q+='b';
			if(s[i]=='b')  cnt++;
			else  cnt--;
	  	  }
	  	  else  q+=c;//后面调整不回来了 
		}  
  	  }
  	  return q;
    }